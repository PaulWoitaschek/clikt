{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Clikt (pronounced \u201cclicked\u201d) is a multiplatform Kotlin library that makes writing command line interfaces simple and intuitive. It\u2019s the \u201cCommand Line Interface for Kotlin\u201d. It is designed to make the process of writing command line tools effortless while supporting a wide variety of use cases and allowing advanced customization when needed. Clikt has: arbitrary nesting of commands composable, type safe parameter values generation of help output and shell autocomplete scripts multiplatform packages for JVM, NodeJS, and native Linux, Windows and MacOS What does it look like? Here\u2019s a complete example of a simple Clikt program: class Hello : CliktCommand () { val count : Int by option ( help = \"Number of greetings\" ). int (). default ( 1 ) val name : String by option ( help = \"The person to greet\" ). prompt ( \"Your name\" ) override fun run () { repeat ( count ) { echo ( \"Hello $ name !\" ) } } } fun main ( args : Array < String > ) = Hello (). main ( args ) And here\u2019s what it looks like when run: $ ./hello --count=3 Your name: John Hello John! Hello John! Hello John! The help page is generated for you: $ ./hello --help Usage: hello [OPTIONS] Options: --count INT Number of greetings --name TEXT The person to greet -h, --help Show this message and exit Errors are also taken care of: $ ./hello --whoops Usage: hello [OPTIONS] Error: no such option: \"--whoops\". Installation \u00b6 Clikt is distributed through Maven Central . dependencies { implementation ( \"com.github.ajalt.clikt:clikt:3.5.0\" ) } If you\u2019re using Maven instead of Gradle, use <artifactId>clikt-jvm</artifactId> \u00b6 Multiplatform \u00b6 Clikt supports the following targets: jvm , mingwX64 , linuxX64 , macosX64 , and js (for both NodeJS and Browsers). Artifacts for macosArm64 are also published, but not tested with CI. See the docs for more information about functionality supported on each target. You\u2019ll need to use Gradle 6 or newer. Snapshots \u00b6 Snapshot builds are also available You'll need to add the Sonatype snapshots repository: repositories { maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots/\" ) } } API Reference \u00b6 Commands and Exceptions Options Arguments Parameter Type Conversions Output Formatting","title":"Home"},{"location":"#installation","text":"Clikt is distributed through Maven Central . dependencies { implementation ( \"com.github.ajalt.clikt:clikt:3.5.0\" ) }","title":"Installation"},{"location":"#if-youre-using-maven-instead-of-gradle-use-artifactidclikt-jvmartifactid","text":"","title":"If you're using Maven instead of Gradle, use &lt;artifactId&gt;clikt-jvm&lt;/artifactId&gt;"},{"location":"#multiplatform","text":"Clikt supports the following targets: jvm , mingwX64 , linuxX64 , macosX64 , and js (for both NodeJS and Browsers). Artifacts for macosArm64 are also published, but not tested with CI. See the docs for more information about functionality supported on each target. You\u2019ll need to use Gradle 6 or newer.","title":"Multiplatform"},{"location":"#snapshots","text":"Snapshot builds are also available You'll need to add the Sonatype snapshots repository: repositories { maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots/\" ) } }","title":"Snapshots"},{"location":"#api-reference","text":"Commands and Exceptions Options Arguments Parameter Type Conversions Output Formatting","title":"API Reference"},{"location":"advanced/","text":"Advanced Patterns \u00b6 Common Options With Subcommands \u00b6 In some cases, you will have multiple subcommands that all share a common set of options. For example, you may have an option for a config file, or an output directory, or some API credentials. There are several ways to structure your commands to avoid repeating the option declarations in each subcommand. Defining Common Options on the Root Command \u00b6 You can define your options on the root command and pass down the information via the context. With this design, you\u2019ll have to specify the common options before the subcommand name on the command line. Example class Config ( val token : String , val hostname : String ) class MyApi : CliktCommand () { private val token by option ( help = \"api token to use for requests\" ). default ( \"...\" ) private val hostname by option ( help = \"base url for requests\" ). default ( \"example.com\" ) override fun run () { currentContext . obj = Config ( token , hostname ) } } class Store : CliktCommand () { private val file by option ( help = \"file to store\" ). file ( canBeDir = false ) private val config by requireObject < Config > () override fun run () { myApiStoreFile ( config . token , config . hostname , file ) } } class Fetch : CliktCommand () { private val outdir by option ( help = \"directory to store file in\" ). file ( canBeFile = false ) private val config by requireObject < Config > () override fun run () { myApiFetchFile ( config . token , config . hostname , outdir ) } } fun main ( args : Array < String > ) = MyApi (). subcommands ( Store (), Fetch ()). main ( args ) Usage 1 $ ./myapi --hostname=https://example.com store file.txt Usage 2 $ ./myapi --hostname=https://example.com fetch --outdir=./out Defining Common Options in a Group \u00b6 Instead of defining your common options on the root command, you can instead define them in an OptionGroup which you include in each subcommand. This allows you to specify all options after the subcommand name. Example class CommonOptions : OptionGroup ( \"Standard Options:\" ) { val token by option ( help = \"api token to use for requests\" ). default ( \"...\" ) val hostname by option ( help = \"base url for requests\" ). default ( \"example.com\" ) } class MyApi : NoOpCliktCommand () class Store : CliktCommand () { private val commonOptions by CommonOptions () private val file by option ( help = \"file to store\" ). file ( canBeDir = false ) override fun run () { myApiStoreFile ( commonOptions . token , commonOptions . hostname , file ) } } class Fetch : CliktCommand () { private val commonOptions by CommonOptions () private val outdir by option ( help = \"directory to store file in\" ). file ( canBeFile = false ) override fun run () { myApiFetchFile ( commonOptions . token , commonOptions . hostname , outdir ) } } fun main ( args : Array < String > ) = MyApi (). subcommands ( Store (), Fetch ()). main ( args ) Usage 1 $ ./myapi store --hostname=https://example.com file.txt Usage 2 $ ./myapi fetch --hostname=https://example.com --outdir=./out Defining Common Options in a Base Class \u00b6 A third design to share options is to define the common options in a base class that all the subcommands inherit from. Example abstract class MyApiSubcommand : CliktCommand () { val token by option ( help = \"api token to use for requests\" ). default ( \"...\" ) val hostname by option ( help = \"base url for requests\" ). default ( \"example.com\" ) } class MyApi : NoOpCliktCommand () class Store : MyApiSubcommand () { private val file by option ( help = \"file to store\" ). file ( canBeDir = false ) override fun run () { myApiStoreFile ( token , hostname , file ) } } class Fetch : MyApiSubcommand () { private val outdir by option ( help = \"directory to store file in\" ). file ( canBeFile = false ) override fun run () { myApiFetchFile ( token , hostname , outdir ) } } fun main ( args : Array < String > ) = MyApi (). subcommands ( Store (), Fetch ()). main ( args ) Usage 1 $ ./myapi store --hostname=https://example.com file.txt Usage 2 $ ./myapi fetch --hostname=https://example.com --outdir=./out Command Aliases \u00b6 Clikt allows commands to alias command names to sequences of tokens. This allows you to implement common patterns like allowing the user to invoke a command by typing a prefix of its name, or user-defined aliases like the way you can configure git to accept git ci as an alias for git commit . To implement command aliases, override CliktCommand.aliases in your command. This function is called once at the start of parsing, and returns a map of aliases to the tokens that they alias to. To implement git-style aliases: Example class Repo : NoOpCliktCommand () { // You could load the aliases from a config file etc. override fun aliases (): Map < String , List < String >> = mapOf ( \"ci\" to listOf ( \"commit\" ), \"cm\" to listOf ( \"commit\" , \"-m\" ) ) } class Commit : CliktCommand () { val message by option ( \"-m\" ). default ( \"\" ) override fun run () { echo ( \"Committing with message: $ message \" ) } } fun main ( args : Array < String > ) = Repo (). subcommands ( Commit ()). main ( args ) Usage 1 $ ./repo ci -m 'my message' Committing with message: my message Usage 2 $ ./repo cm 'my message' Committing with message: my message Note that aliases are not expanded recursively: none of the tokens that an alias expands to will be expanded again, even if they match another alias. You also use this functionality to implement command prefixes: Example class Tool : NoOpCliktCommand () { override fun aliases (): Map < String , List < String >> { val prefixCounts = mutableMapOf < String , Int > (). withDefault { 0 } val prefixes = mutableMapOf < String , List < String >> () for ( name in registeredSubcommandNames ()) { if ( name . length < 3 ) continue for ( i in 1. . name . lastIndex ) { val prefix = name . substring ( 0. . i ) prefixCounts [ prefix ] = prefixCounts . getValue ( prefix ) + 1 prefixes [ prefix ] = listOf ( name ) } } return prefixes . filterKeys { prefixCounts . getValue ( it ) == 1 } } } class Foo : CliktCommand () { override fun run () { echo ( \"Running Foo\" ) } } class Bar : CliktCommand () { override fun run () { echo ( \"Running Bar\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Foo (), Bar ()). main ( args ) Usage $ ./tool ba Running Bar Token Normalization \u00b6 To prevent ambiguities in parsing, aliases are only supported for command names. However, there\u2019s another way to modify user input that works on more types of tokens. You can set a tokenTransformer on the command\u2019s context that will be called for each option and command name that is input. This can be used to implement case-insensitive parsing, for example: Example class Hello : CliktCommand () { init { context { tokenTransformer = { it . lowercase () } } } val name by option () override fun run () = echo ( \"Hello $ name !\" ) } Usage $ ./hello --NAME=Foo Hello Foo! Replacing stdin and stdout \u00b6 By default, functions like CliktCommand.main and option().prompt() read from System.in and write to System.out . If you want to use clikt in an environment where the standard streams aren\u2019t available, you can set your own implementation of CliktConsole when customizing the command context . object MyConsole : CliktConsole { override fun promptForLine ( prompt : String , hideInput : Boolean ): String? { MyOutputStream . write ( prompt ) return if ( hideInput ) MyInputStream . readPassword () else MyInputStream . readLine () } override fun print ( text : String , error : Boolean ) { if ( error ) MyOutputStream . writeError ( prompt ) else MyOutputStream . write ( prompt ) } override val lineSeparator : String get () = \"\\n\" } class CustomCLI : NoOpCliktCommand () { init { context { console = MyConsole } } } Command Line Argument Files (\u201c@argfiles\u201d) \u00b6 Similar to javac , Clikt supports loading command line parameters from a file using the \u201c@argfile\u201d syntax. You can pass any file path to a command prefixed with @ , and the file will be expanded into the command line parameters. This can be useful on operating systems like Windows that have command line length limits. If you create a file named cliargs with content like this: --number 1 --name='jane doe' --age=30 ./file.txt You can call your command with the contents of the file like this: $ ./tool @cliargs Which is equivalent to calling it like this: $ ./tool --number 1 --name='jane doe' --age=30 ./file.txt You can use any file path after the @ , and can specify multiple @argfiles: $ ./tool @../config/args @C:\\\\Program\\ Files\\\\Tool\\\\argfile If you have any options with names that start with @ , you can still use @argfiles , but values on the command line that match an option will be parsed as that option, rather than an @argfile , so you\u2019ll have to give your files a different name. Preventing @argfile expansion \u00b6 If you want to use a value starting with @ as an argument without expanding it, you have three options: Pass it after a -- , which disables expansion for everything that occurs after it . Escape it with @@ . The first @ will be removed and the rest used as the argument value. For example, @@file will parse as the string @file Disable @argfile expansion entirely by setting Context.expandArgumentFiles = false File format \u00b6 Normal shell quoting and escaping rules apply. Line breaks are treated as word separators, and can be used where you would normally use a space to separate parameters. Line breaks can occur within quotes, and will be included in the quoted value. @argfiles can contain other @argfile arguments, which will be expanded recursively. An unescaped # character outside of quotes is treated as a line comment: it and the rest of the line are skipped. You can pass a literal # by escaping it with \\# or quoting it with '#' . If a \\ occurs at the end of a line, the next line is trimmed of leading whitespace and the two lines are concatenated. Testing your Clikt CLI \u00b6 CliktCommand.main calls exitProcess when invalid values are provided on the command line. In unit tests, you should instead call CliktCommand.parse , which throws exceptions with error details rather than printing the details and exiting the process. See the documentation on exceptions for more information. If your command uses environment variables, you can set a function on the context that returns test values. Custom exit status codes \u00b6 Clikt will normally exit your program with a status code of 0 for a normal execution, or 1 if there\u2019s an error. If you want to use a different value, you can throw ProgramResult(statusCode) . If you use CliktCommand.main , that exception will be caught and exitProcess will be called with the value of statusCode . You could also call exitProcess yourself, but the ProgramResult has a couple of advantages: ProgramResult is easier to test. Exiting the process makes unit tests difficult to run. ProgramResult works on all platforms. exitProcess is only available on the JVM. Multiplatform Support \u00b6 Clikt supports the following platforms in addition to JVM: Desktop native (Linux, Windows, and MacOS) \u00b6 All functionality is supported, except the env parameter of editText and editFile , and the hideInput parameter of prompt are ignored. NodeJS \u00b6 All functionality is supported, except the hideInput parameter of prompt is ignored. Browser JavaScript \u00b6 The default CliktConsole only outputs to the browser\u2019s developer console, which is probably not what you want. You can define your own CliktConsole , or you can call parse instead of main and handle output yourself. editText and editFile are not supported. prompt is only supported if you define your own CliktConsole.","title":"Common Options With Subcommands"},{"location":"advanced/#advanced-patterns","text":"","title":"Advanced Patterns"},{"location":"advanced/#common-options-with-subcommands","text":"In some cases, you will have multiple subcommands that all share a common set of options. For example, you may have an option for a config file, or an output directory, or some API credentials. There are several ways to structure your commands to avoid repeating the option declarations in each subcommand.","title":"Common Options With Subcommands"},{"location":"advanced/#defining-common-options-on-the-root-command","text":"You can define your options on the root command and pass down the information via the context. With this design, you\u2019ll have to specify the common options before the subcommand name on the command line. Example class Config ( val token : String , val hostname : String ) class MyApi : CliktCommand () { private val token by option ( help = \"api token to use for requests\" ). default ( \"...\" ) private val hostname by option ( help = \"base url for requests\" ). default ( \"example.com\" ) override fun run () { currentContext . obj = Config ( token , hostname ) } } class Store : CliktCommand () { private val file by option ( help = \"file to store\" ). file ( canBeDir = false ) private val config by requireObject < Config > () override fun run () { myApiStoreFile ( config . token , config . hostname , file ) } } class Fetch : CliktCommand () { private val outdir by option ( help = \"directory to store file in\" ). file ( canBeFile = false ) private val config by requireObject < Config > () override fun run () { myApiFetchFile ( config . token , config . hostname , outdir ) } } fun main ( args : Array < String > ) = MyApi (). subcommands ( Store (), Fetch ()). main ( args ) Usage 1 $ ./myapi --hostname=https://example.com store file.txt Usage 2 $ ./myapi --hostname=https://example.com fetch --outdir=./out","title":"Defining Common Options on the Root Command"},{"location":"advanced/#defining-common-options-in-a-group","text":"Instead of defining your common options on the root command, you can instead define them in an OptionGroup which you include in each subcommand. This allows you to specify all options after the subcommand name. Example class CommonOptions : OptionGroup ( \"Standard Options:\" ) { val token by option ( help = \"api token to use for requests\" ). default ( \"...\" ) val hostname by option ( help = \"base url for requests\" ). default ( \"example.com\" ) } class MyApi : NoOpCliktCommand () class Store : CliktCommand () { private val commonOptions by CommonOptions () private val file by option ( help = \"file to store\" ). file ( canBeDir = false ) override fun run () { myApiStoreFile ( commonOptions . token , commonOptions . hostname , file ) } } class Fetch : CliktCommand () { private val commonOptions by CommonOptions () private val outdir by option ( help = \"directory to store file in\" ). file ( canBeFile = false ) override fun run () { myApiFetchFile ( commonOptions . token , commonOptions . hostname , outdir ) } } fun main ( args : Array < String > ) = MyApi (). subcommands ( Store (), Fetch ()). main ( args ) Usage 1 $ ./myapi store --hostname=https://example.com file.txt Usage 2 $ ./myapi fetch --hostname=https://example.com --outdir=./out","title":"Defining Common Options in a Group"},{"location":"advanced/#defining-common-options-in-a-base-class","text":"A third design to share options is to define the common options in a base class that all the subcommands inherit from. Example abstract class MyApiSubcommand : CliktCommand () { val token by option ( help = \"api token to use for requests\" ). default ( \"...\" ) val hostname by option ( help = \"base url for requests\" ). default ( \"example.com\" ) } class MyApi : NoOpCliktCommand () class Store : MyApiSubcommand () { private val file by option ( help = \"file to store\" ). file ( canBeDir = false ) override fun run () { myApiStoreFile ( token , hostname , file ) } } class Fetch : MyApiSubcommand () { private val outdir by option ( help = \"directory to store file in\" ). file ( canBeFile = false ) override fun run () { myApiFetchFile ( token , hostname , outdir ) } } fun main ( args : Array < String > ) = MyApi (). subcommands ( Store (), Fetch ()). main ( args ) Usage 1 $ ./myapi store --hostname=https://example.com file.txt Usage 2 $ ./myapi fetch --hostname=https://example.com --outdir=./out","title":"Defining Common Options in a Base Class"},{"location":"advanced/#command-aliases","text":"Clikt allows commands to alias command names to sequences of tokens. This allows you to implement common patterns like allowing the user to invoke a command by typing a prefix of its name, or user-defined aliases like the way you can configure git to accept git ci as an alias for git commit . To implement command aliases, override CliktCommand.aliases in your command. This function is called once at the start of parsing, and returns a map of aliases to the tokens that they alias to. To implement git-style aliases: Example class Repo : NoOpCliktCommand () { // You could load the aliases from a config file etc. override fun aliases (): Map < String , List < String >> = mapOf ( \"ci\" to listOf ( \"commit\" ), \"cm\" to listOf ( \"commit\" , \"-m\" ) ) } class Commit : CliktCommand () { val message by option ( \"-m\" ). default ( \"\" ) override fun run () { echo ( \"Committing with message: $ message \" ) } } fun main ( args : Array < String > ) = Repo (). subcommands ( Commit ()). main ( args ) Usage 1 $ ./repo ci -m 'my message' Committing with message: my message Usage 2 $ ./repo cm 'my message' Committing with message: my message Note that aliases are not expanded recursively: none of the tokens that an alias expands to will be expanded again, even if they match another alias. You also use this functionality to implement command prefixes: Example class Tool : NoOpCliktCommand () { override fun aliases (): Map < String , List < String >> { val prefixCounts = mutableMapOf < String , Int > (). withDefault { 0 } val prefixes = mutableMapOf < String , List < String >> () for ( name in registeredSubcommandNames ()) { if ( name . length < 3 ) continue for ( i in 1. . name . lastIndex ) { val prefix = name . substring ( 0. . i ) prefixCounts [ prefix ] = prefixCounts . getValue ( prefix ) + 1 prefixes [ prefix ] = listOf ( name ) } } return prefixes . filterKeys { prefixCounts . getValue ( it ) == 1 } } } class Foo : CliktCommand () { override fun run () { echo ( \"Running Foo\" ) } } class Bar : CliktCommand () { override fun run () { echo ( \"Running Bar\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Foo (), Bar ()). main ( args ) Usage $ ./tool ba Running Bar","title":"Command Aliases"},{"location":"advanced/#token-normalization","text":"To prevent ambiguities in parsing, aliases are only supported for command names. However, there\u2019s another way to modify user input that works on more types of tokens. You can set a tokenTransformer on the command\u2019s context that will be called for each option and command name that is input. This can be used to implement case-insensitive parsing, for example: Example class Hello : CliktCommand () { init { context { tokenTransformer = { it . lowercase () } } } val name by option () override fun run () = echo ( \"Hello $ name !\" ) } Usage $ ./hello --NAME=Foo Hello Foo!","title":"Token Normalization"},{"location":"advanced/#replacing-stdin-and-stdout","text":"By default, functions like CliktCommand.main and option().prompt() read from System.in and write to System.out . If you want to use clikt in an environment where the standard streams aren\u2019t available, you can set your own implementation of CliktConsole when customizing the command context . object MyConsole : CliktConsole { override fun promptForLine ( prompt : String , hideInput : Boolean ): String? { MyOutputStream . write ( prompt ) return if ( hideInput ) MyInputStream . readPassword () else MyInputStream . readLine () } override fun print ( text : String , error : Boolean ) { if ( error ) MyOutputStream . writeError ( prompt ) else MyOutputStream . write ( prompt ) } override val lineSeparator : String get () = \"\\n\" } class CustomCLI : NoOpCliktCommand () { init { context { console = MyConsole } } }","title":"Replacing stdin and stdout"},{"location":"advanced/#command-line-argument-files-argfiles","text":"Similar to javac , Clikt supports loading command line parameters from a file using the \u201c@argfile\u201d syntax. You can pass any file path to a command prefixed with @ , and the file will be expanded into the command line parameters. This can be useful on operating systems like Windows that have command line length limits. If you create a file named cliargs with content like this: --number 1 --name='jane doe' --age=30 ./file.txt You can call your command with the contents of the file like this: $ ./tool @cliargs Which is equivalent to calling it like this: $ ./tool --number 1 --name='jane doe' --age=30 ./file.txt You can use any file path after the @ , and can specify multiple @argfiles: $ ./tool @../config/args @C:\\\\Program\\ Files\\\\Tool\\\\argfile If you have any options with names that start with @ , you can still use @argfiles , but values on the command line that match an option will be parsed as that option, rather than an @argfile , so you\u2019ll have to give your files a different name.","title":"Command Line Argument Files (\"@argfiles\")"},{"location":"advanced/#preventing-argfile-expansion","text":"If you want to use a value starting with @ as an argument without expanding it, you have three options: Pass it after a -- , which disables expansion for everything that occurs after it . Escape it with @@ . The first @ will be removed and the rest used as the argument value. For example, @@file will parse as the string @file Disable @argfile expansion entirely by setting Context.expandArgumentFiles = false","title":"Preventing @argfile expansion"},{"location":"advanced/#file-format","text":"Normal shell quoting and escaping rules apply. Line breaks are treated as word separators, and can be used where you would normally use a space to separate parameters. Line breaks can occur within quotes, and will be included in the quoted value. @argfiles can contain other @argfile arguments, which will be expanded recursively. An unescaped # character outside of quotes is treated as a line comment: it and the rest of the line are skipped. You can pass a literal # by escaping it with \\# or quoting it with '#' . If a \\ occurs at the end of a line, the next line is trimmed of leading whitespace and the two lines are concatenated.","title":"File format"},{"location":"advanced/#testing-your-clikt-cli","text":"CliktCommand.main calls exitProcess when invalid values are provided on the command line. In unit tests, you should instead call CliktCommand.parse , which throws exceptions with error details rather than printing the details and exiting the process. See the documentation on exceptions for more information. If your command uses environment variables, you can set a function on the context that returns test values.","title":"Testing your Clikt CLI"},{"location":"advanced/#custom-exit-status-codes","text":"Clikt will normally exit your program with a status code of 0 for a normal execution, or 1 if there\u2019s an error. If you want to use a different value, you can throw ProgramResult(statusCode) . If you use CliktCommand.main , that exception will be caught and exitProcess will be called with the value of statusCode . You could also call exitProcess yourself, but the ProgramResult has a couple of advantages: ProgramResult is easier to test. Exiting the process makes unit tests difficult to run. ProgramResult works on all platforms. exitProcess is only available on the JVM.","title":"Custom exit status codes"},{"location":"advanced/#multiplatform-support","text":"Clikt supports the following platforms in addition to JVM:","title":"Multiplatform Support"},{"location":"advanced/#desktop-native-linux-windows-and-macos","text":"All functionality is supported, except the env parameter of editText and editFile , and the hideInput parameter of prompt are ignored.","title":"Desktop native (Linux, Windows, and MacOS)"},{"location":"advanced/#nodejs","text":"All functionality is supported, except the hideInput parameter of prompt is ignored.","title":"NodeJS"},{"location":"advanced/#browser-javascript","text":"The default CliktConsole only outputs to the browser\u2019s developer console, which is probably not what you want. You can define your own CliktConsole , or you can call parse instead of main and handle output yourself. editText and editFile are not supported. prompt is only supported if you define your own CliktConsole.","title":"Browser JavaScript"},{"location":"arguments/","text":"Arguments \u00b6 Arguments are declared and customized similarly to options , but are provided on the command line positionally instead of by name. Arguments are declared with argument() , and the order that they are declared defines the order that they must be provided on the command line. Basic Arguments \u00b6 By default, argument takes a single String value which is required to be provided on the command line. Example class Hello : CliktCommand () { val name by argument () override fun run () { echo ( \"Hello $ name !\" ) } } Usage $ ./hello Foo Hello Foo! Arguments appear in the usage string, but normally aren\u2019t listed in the help page. It\u2019s usually more clear to document arguments in the command help. Example class Cp : CliktCommand ( help = \"Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST.\" ) { private val source by argument (). file ( mustExist = true ). multiple () private val dest by argument (). file () override fun run () { // ... } } Help Output Usage: cp [OPTIONS] [SOURCE]... DEST Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST. Options: -h, --help Show this message and exit Variadic Arguments \u00b6 Like options , arguments can take any fixed number of values, which you can change with functions like pair and triple . Unlike options, arguments can also take a variable (or unlimited) number of values. This is common with file path arguments, since they are frequently expanded with a glob pattern on the command line. Variadic arguments are declared with multiple . You can declare any number of arguments with fixed numbers of values, but only one variadic argument in a command. Example class Copy : CliktCommand () { val source : List < Path > by argument (). path ( mustExist = true ). multiple () val dest : Path by argument (). path ( canBeFile = false ) override fun run () { echo ( \"Copying files $ source to $ dest \" ) } } Usage $ ./copy file.* out/ Copying files [file.txt, file.md] to out/ You can also use unique to discard duplicates: val source : Set < Path > by argument (). path ( mustExist = true ). multiple (). unique () Option-Like Arguments (Using -- ) \u00b6 Clikt normally parses any value that starts with punctuation as an option, which allows users to intermix options and arguments. However, sometimes you need to pass a value that starts with punctuation to an argument. For example, you might have a file named -file.txt that you want to use as an argument. Clikt supports the POSIX convention of using -- to force all following values to be treated as arguments. Any values before the -- will be parsed normally. Example class Touch : CliktCommand () { val verbose by option (). flag () val files by argument (). multiple () override fun run () { if ( verbose ) echo ( files . joinToString ( \"\\n\" )) } } Usage 1 $ ./touch --foo.txt Usage: touch [OPTIONS] [FILES]... Error: no such option: \"--foo.txt\". Usage 2 $ ./touch --verbose -- --foo.txt bar.txt --foo.txt bar.txt","title":"Basic Arguments"},{"location":"arguments/#arguments","text":"Arguments are declared and customized similarly to options , but are provided on the command line positionally instead of by name. Arguments are declared with argument() , and the order that they are declared defines the order that they must be provided on the command line.","title":"Arguments"},{"location":"arguments/#basic-arguments","text":"By default, argument takes a single String value which is required to be provided on the command line. Example class Hello : CliktCommand () { val name by argument () override fun run () { echo ( \"Hello $ name !\" ) } } Usage $ ./hello Foo Hello Foo! Arguments appear in the usage string, but normally aren\u2019t listed in the help page. It\u2019s usually more clear to document arguments in the command help. Example class Cp : CliktCommand ( help = \"Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST.\" ) { private val source by argument (). file ( mustExist = true ). multiple () private val dest by argument (). file () override fun run () { // ... } } Help Output Usage: cp [OPTIONS] [SOURCE]... DEST Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST. Options: -h, --help Show this message and exit","title":"Basic Arguments"},{"location":"arguments/#variadic-arguments","text":"Like options , arguments can take any fixed number of values, which you can change with functions like pair and triple . Unlike options, arguments can also take a variable (or unlimited) number of values. This is common with file path arguments, since they are frequently expanded with a glob pattern on the command line. Variadic arguments are declared with multiple . You can declare any number of arguments with fixed numbers of values, but only one variadic argument in a command. Example class Copy : CliktCommand () { val source : List < Path > by argument (). path ( mustExist = true ). multiple () val dest : Path by argument (). path ( canBeFile = false ) override fun run () { echo ( \"Copying files $ source to $ dest \" ) } } Usage $ ./copy file.* out/ Copying files [file.txt, file.md] to out/ You can also use unique to discard duplicates: val source : Set < Path > by argument (). path ( mustExist = true ). multiple (). unique ()","title":"Variadic Arguments"},{"location":"arguments/#option-like-arguments-using-","text":"Clikt normally parses any value that starts with punctuation as an option, which allows users to intermix options and arguments. However, sometimes you need to pass a value that starts with punctuation to an argument. For example, you might have a file named -file.txt that you want to use as an argument. Clikt supports the POSIX convention of using -- to force all following values to be treated as arguments. Any values before the -- will be parsed normally. Example class Touch : CliktCommand () { val verbose by option (). flag () val files by argument (). multiple () override fun run () { if ( verbose ) echo ( files . joinToString ( \"\\n\" )) } } Usage 1 $ ./touch --foo.txt Usage: touch [OPTIONS] [FILES]... Error: no such option: \"--foo.txt\". Usage 2 $ ./touch --verbose -- --foo.txt bar.txt --foo.txt bar.txt","title":"Option-Like Arguments (Using --)"},{"location":"autocomplete/","text":"Shell Autocomplete \u00b6 Clikt includes built-in support for generating autocomplete scripts for bash, zsh and fish shells. Example $ ./repo <TAB><TAB> commit clone pull $ ./repo -<TAB> --config -h --help --repo-home --verbose $./repo --repo-home ./g<TAB> ./git ./got ./good Enabling Completion \u00b6 Clikt handles autocomplete by generating a shell script that defines the completion. You generate the script once each time your CLI changes, and load it each time your start your shell. With an environment variable \u00b6 You can generate the completion script by invoking your program with a special environment variable. You can set the variable name manually with the autoCompleteEnvvar parameter in the CliktCommand constructor . By default it\u2019s your command\u2019s name capitalized, with - replaced with _ , and prefixed with another _ . So if your command name is my-command , the variable would be _MY_COMMAND_COMPLETE=bash , _MY_COMMAND_COMPLETE=zsh , or _MY_COMMAND_COMPLETE=fish , depending on your current shell. For example to activate bash autocomplete for this command: class MyProgram : CliktCommand () { // ... } You can generate the completion script and save it to a file like this: $ _MY_PROGRAM_COMPLETE = bash ./my-program > ~/my-program-completion.sh With an option \u00b6 If you\u2019d prefer not to use environment variables, you can add a special option to your command with the completionOption function. Invoking your program with this option will generate the completion script: Example 1 class MyCommand : CliktCommand () { init { completionOption () } // ... } Example 2 class MyCommand : CliktCommand () { //.. } fun main ( args : Array < String > ) = MyCommand (). completionOption (). main ( args ) Usage $ ./my-command --generate-completion=bash > ~/my-program-completion.sh With a subcommand \u00b6 A third option is to add a subcommand that will generate the completion when invoked. Example 1 class MyCommand : CliktCommand () { init { subcommands ( CompletionCommand ()) } // ... } Example 2 class MyCommand : CliktCommand () { //.. } fun main ( args : Array < String > ) = MyCommand (). subcommands ( CompletionCommand ()). main ( args ) Usage $ ./my-command generate-completion bash > ~/my-program-completion.sh Using the generated script \u00b6 Once you\u2019ve generated the completion script, source the file to activate completion: $ source ~/my-program-completion.sh You can add that source command to your startup script so that completion is always available. For example, with bash: $ echo source ~/my-program-completion.sh >> ~/.bashrc You\u2019ll need to regenerate the completion script any time your command structure changes. Supported Functionality \u00b6 Bash and Zsh \u00b6 Currently subcommand, option, and command alias names can be completed, as well as values for options and arguments. choice parameters are completed with their possible values. Other parameter types are completed as file or directory names. Context.allowInterspersedArgs is supported. Fish \u00b6 Fish\u2019s completion mechanism is more limited that Bash\u2019s. Subcommands can be completed, options can be completed as long as they start with a - . Completion suggestions for positional arguments are the union of all positional arguments. Other advanced Clikt features are not supported. Customizing Completions \u00b6 There is built-in completion for values for choice parameters, and for parameters converted with file and path . You can add completion for other parameters with the completionCandidates parameter to option() and argument() . The value can be one of the following: None : The default. The parameter\u2019s values will not be completed. Path : Completions will be filesystem paths. Hostname : Completions will be read from the system\u2019s hosts file. Username : Completions will be taken from the system\u2019s users. Fixed : Completions are given as a fixed set of strings. Custom : Completions are generated from a custom script. Custom completion candidates \u00b6 The Custom type takes a block that returns code to add to the script which generates completions for the given parameter. If you just want to call another script or binary that prints all possible completion words to stdout, you can use fromStdout . Both Bash and ZSH scripts use Bash\u2019s Programmable Completion system (ZSH via a comparability layer). The string returned from [generator] should be the body of a function that will be passed to compgen -F . Specifically, you should set the variable COMPREPLY to the completion(s) for the current word being typed. The word being typed can be retrieved from the COMP_WORDS array at index COMP_CWORD . Example with fromStdout class Hello : CliktCommand () { // This example uses `echo`, but you would use your own binary // or script that prints the completions. val name by option ( completionCandidates = CompletionCandidates . Custom . fromStdout ( \"echo completion1 completion2\" ) ) override fun run () { echo ( \"Hello, $ name !\" ) } } Example with full script class Hello : CliktCommand () { // This is identical to the previous example val name by option ( completionCandidates = CompletionCandidates . Custom { \"\"\" WORDS= ${ '$' } (echo completion1 completion2) COMPREPLY=( ${ '$' } (compgen -W \" ${ '$' } WORDS\" -- \" ${ '$' } {COMP_WORDS[ ${ '$' } COMP_CWORD]}\")) \"\"\" . trimIndent () }) override fun run () { echo ( \"Hello, $ name !\" ) } } Limitations \u00b6 Token Normalization is not supported. If you have arguments that occur after a multiple argument, those arguments won\u2019t be autocompleted. Partial command lines are ambiguous in those situations, and Clikt assumes that you\u2019re trying to complete the multiple argument rather than the later ones. Bash must be at least version 3, or Zsh must be at least version 4.1.","title":"Supported Functionality"},{"location":"autocomplete/#shell-autocomplete","text":"Clikt includes built-in support for generating autocomplete scripts for bash, zsh and fish shells. Example $ ./repo <TAB><TAB> commit clone pull $ ./repo -<TAB> --config -h --help --repo-home --verbose $./repo --repo-home ./g<TAB> ./git ./got ./good","title":"Shell Autocomplete"},{"location":"autocomplete/#enabling-completion","text":"Clikt handles autocomplete by generating a shell script that defines the completion. You generate the script once each time your CLI changes, and load it each time your start your shell.","title":"Enabling Completion"},{"location":"autocomplete/#with-an-environment-variable","text":"You can generate the completion script by invoking your program with a special environment variable. You can set the variable name manually with the autoCompleteEnvvar parameter in the CliktCommand constructor . By default it\u2019s your command\u2019s name capitalized, with - replaced with _ , and prefixed with another _ . So if your command name is my-command , the variable would be _MY_COMMAND_COMPLETE=bash , _MY_COMMAND_COMPLETE=zsh , or _MY_COMMAND_COMPLETE=fish , depending on your current shell. For example to activate bash autocomplete for this command: class MyProgram : CliktCommand () { // ... } You can generate the completion script and save it to a file like this: $ _MY_PROGRAM_COMPLETE = bash ./my-program > ~/my-program-completion.sh","title":"With an environment variable"},{"location":"autocomplete/#with-an-option","text":"If you\u2019d prefer not to use environment variables, you can add a special option to your command with the completionOption function. Invoking your program with this option will generate the completion script: Example 1 class MyCommand : CliktCommand () { init { completionOption () } // ... } Example 2 class MyCommand : CliktCommand () { //.. } fun main ( args : Array < String > ) = MyCommand (). completionOption (). main ( args ) Usage $ ./my-command --generate-completion=bash > ~/my-program-completion.sh","title":"With an option"},{"location":"autocomplete/#with-a-subcommand","text":"A third option is to add a subcommand that will generate the completion when invoked. Example 1 class MyCommand : CliktCommand () { init { subcommands ( CompletionCommand ()) } // ... } Example 2 class MyCommand : CliktCommand () { //.. } fun main ( args : Array < String > ) = MyCommand (). subcommands ( CompletionCommand ()). main ( args ) Usage $ ./my-command generate-completion bash > ~/my-program-completion.sh","title":"With a subcommand"},{"location":"autocomplete/#using-the-generated-script","text":"Once you\u2019ve generated the completion script, source the file to activate completion: $ source ~/my-program-completion.sh You can add that source command to your startup script so that completion is always available. For example, with bash: $ echo source ~/my-program-completion.sh >> ~/.bashrc You\u2019ll need to regenerate the completion script any time your command structure changes.","title":"Using the generated script"},{"location":"autocomplete/#supported-functionality","text":"","title":"Supported Functionality"},{"location":"autocomplete/#bash-and-zsh","text":"Currently subcommand, option, and command alias names can be completed, as well as values for options and arguments. choice parameters are completed with their possible values. Other parameter types are completed as file or directory names. Context.allowInterspersedArgs is supported.","title":"Bash and Zsh"},{"location":"autocomplete/#fish","text":"Fish\u2019s completion mechanism is more limited that Bash\u2019s. Subcommands can be completed, options can be completed as long as they start with a - . Completion suggestions for positional arguments are the union of all positional arguments. Other advanced Clikt features are not supported.","title":"Fish"},{"location":"autocomplete/#customizing-completions","text":"There is built-in completion for values for choice parameters, and for parameters converted with file and path . You can add completion for other parameters with the completionCandidates parameter to option() and argument() . The value can be one of the following: None : The default. The parameter\u2019s values will not be completed. Path : Completions will be filesystem paths. Hostname : Completions will be read from the system\u2019s hosts file. Username : Completions will be taken from the system\u2019s users. Fixed : Completions are given as a fixed set of strings. Custom : Completions are generated from a custom script.","title":"Customizing Completions"},{"location":"autocomplete/#custom-completion-candidates","text":"The Custom type takes a block that returns code to add to the script which generates completions for the given parameter. If you just want to call another script or binary that prints all possible completion words to stdout, you can use fromStdout . Both Bash and ZSH scripts use Bash\u2019s Programmable Completion system (ZSH via a comparability layer). The string returned from [generator] should be the body of a function that will be passed to compgen -F . Specifically, you should set the variable COMPREPLY to the completion(s) for the current word being typed. The word being typed can be retrieved from the COMP_WORDS array at index COMP_CWORD . Example with fromStdout class Hello : CliktCommand () { // This example uses `echo`, but you would use your own binary // or script that prints the completions. val name by option ( completionCandidates = CompletionCandidates . Custom . fromStdout ( \"echo completion1 completion2\" ) ) override fun run () { echo ( \"Hello, $ name !\" ) } } Example with full script class Hello : CliktCommand () { // This is identical to the previous example val name by option ( completionCandidates = CompletionCandidates . Custom { \"\"\" WORDS= ${ '$' } (echo completion1 completion2) COMPREPLY=( ${ '$' } (compgen -W \" ${ '$' } WORDS\" -- \" ${ '$' } {COMP_WORDS[ ${ '$' } COMP_CWORD]}\")) \"\"\" . trimIndent () }) override fun run () { echo ( \"Hello, $ name !\" ) } }","title":"Custom completion candidates"},{"location":"autocomplete/#limitations","text":"Token Normalization is not supported. If you have arguments that occur after a multiple argument, those arguments won\u2019t be autocompleted. Partial command lines are ambiguous in those situations, and Clikt assumes that you\u2019re trying to complete the multiple argument rather than the later ones. Bash must be at least version 3, or Zsh must be at least version 4.1.","title":"Limitations"},{"location":"changelog/","text":"3.5.0 \u00b6 Added \u00b6 Added hidden parameter to CliktCommand , which will prevent the command from being displayed as a subcommand in help output ( #353 ) Publish artifacts for the macosArm64 target. Note that this target is not tested on CI. ( #352 ) Changed \u00b6 Default values for arguments will now be included in help output when showDefaultValues=true is set on your help formatter ( #357 ) Fixed \u00b6 Fix flags and other options with defaults not being usable in mutuallyExclusiveOptions ( #349 ) Fix CompletionCommand generating completion for itself ( #355 ) 3.4.2 \u00b6 Deprecated \u00b6 TermUi.echo , TermUi.prompt , and TermUi.confirm . Use the equivalent methods on CliktCommand instead. ( #344 ) 3.4.1 \u00b6 Added \u00b6 Publish JS artifacts with new IR compiler, in addition to the legacy format Changed \u00b6 Updated Kotlin to 1.6.20 3.4.0 \u00b6 Changed \u00b6 unique() now works with any option with a list type, not just multiple() options ( #332 ) Updated Kotlin to 1.6.10 Fixed \u00b6 Fixed co-occurring option groups returning null when all options in the group are defined in environment variables ( #330 ) 3.3.0 \u00b6 Added \u00b6 Added default parameter to argument().multiple() ( #305 ) Context.originalArgv that allows you to read the command line arguments from within a command\u2019s run ( #290 ) context { envarReader = {...} } to set a custom function to read from environment variables ( #299 ) Changed \u00b6 defaultLazy values can now reference other parameters, as long the referenced parameters do not also reference other parameters You can now call CliktCommand.context multiple times on the same command, and all builder blocks will be applied Validate values entered to a prompt option, and show another prompt if the validation fails ( #288 ) Updated kotlin to 1.5.31 Fixed \u00b6 Report error when excess arguments are given to a command with allowMultipleSubcommands=true ( #303 ) 3.2.0 \u00b6 Added \u00b6 InputStream.isCliktParameterDefaultStdin and OutputStream.isCliktParameterDefaultStdout to check if the streams returned from inputStream / outputStream options are proxying stdin/stdout ( #272 ) Changed \u00b6 Make parameters of mutuallyExclusiveOptions covariant to allow validation without explicit type annotations. ( #265 ) Updated kotlin to 1.5.0 Fixed \u00b6 Reading from an option or argument property on a command that hasn\u2019t been invoked will now always throw an IllegalStateException 3.1.0 \u00b6 Added \u00b6 Added required() and defaultLazy() for nullable flag options like switch() . ( #240 ) Added support for generating autocomplete scripts for Fish shells ( #189 ) Added CompletionCommand and CliktCommand.completionOption() that will print an autocomplete script when invoked, as an alternative to using environment variables. Changed \u00b6 Updated Kotlin to 1.4.21 @argfiles now allow line breaks in quoted values, which are included in the value verbatim. You can now end lines with \\ to concatenate them with the following line. ( #248 ) 3.0.1 \u00b6 Deprecated \u00b6 Deprecated calling echo with err or lineSeparator but no message . 3.0.0 \u00b6 Added \u00b6 Clikt\u2019s JS target now supports both NodeJS and Browsers. ( #198 ) Default values for switch options are now shown in the help. Help text can be customized using the defaultForHelp argument, similar to normal options. ( #205 ) Added FlagOption.convert ( #208 ) Added ability to use unicode NEL character ( \\u0085 ) to manually break lines in help output ( #214 ) Added help(\"\") extension to options and arguments as an alternative to passing the help as an argument ( #207 ) Added valueSourceKey parameter to option Added check() extensions to options and arguments as an alternative to validate() Added prompt and confirm functions to CliktCommand that call the TermUi equivalents with the current console. Added echo() overload with no parameters to CliktCommand that prints a newline by itself. Added localization support. You can set an implementation of the Localization interface on your context with your translations. ( #227 ) Fixed \u00b6 Hidden options will no longer be suggested as possible typo corrections. ( #202 ) Options and Arguments with multiple(required=true) will now show as required in help output. ( #212 ) Multiple short lines in a help text paragraph no longer appear dedented ( #215 ) Changed \u00b6 Updated Kotlin to 1.4.0 Argument.help and Option.help properties have been renamed to argumentHelp and optionHelp , respectively. The help parameter names to option() and argument() are unchanged. commandHelp and commandHelpEpilog properties on CliktCommand are now open , so you can choose to override them instead of passing help and epilog to the constructor. Replaced MapValueSource.defaultKey with ValueSource.getKey() , which is more customizable. Option.metavar , Option.parameterHelp , OptionGroup.parameterHelp and Argument.parameterHelp properties are now functions. Changed constructor parameters of CliktHelpFormatter . Added localization and removed usageTitle , optionsTitle , argumentsTitle , commandsTitle , optionsMetavar , and commandMetavar . Those strings are now defined on equivalently named functions on Localization . Removed \u00b6 Removed envvarSplit parameter from option() and convert() . Option values from environment variables are no longer split automatically. ( #177 ) Removed public constructors from the following classes: ProcessedArgument , OptionWithValues , FlagOption , CoOccurringOptionGroup , ChoiceGroup , MutuallyExclusiveOptions . MissingParameter exception replaced with MissingOption and MissingArgument Removed Context.helpOptionMessage . Override Localization.helpOptionMessage and set it on your context instead. Deprecated \u00b6 @ExperimentalCompletionCandidates and @ExperimentalValueSourceApi annotations. These APIs no longer require an opt-in. 2.8.0 \u00b6 Added \u00b6 Added error parameter to PrintMessage and PrintHelpMessage . When true , CliktCommand.main will exit with status code 1. ( #187 ) Changed \u00b6 When printHelpOnEmptyArgs is true and no arguments are present, or when invokeWithoutSubcommand is false and no subcommand is present, CliktCommand.main will now exit with status code 1 rather than 0. restrictTo now works with any Comparable value, not just Number . CliktCommand.main now accepts Array<out String> , not just Array<String> . ( #196 ) Fixed \u00b6 Fixed option values being reset when calling multiple subcommands with allowMultipleSubcommands=true ( #190 ) 2.7.1 \u00b6 Fixed \u00b6 Fixed NPE thrown in some cases when using defaultByName ( #179 ) 2.7.0 \u00b6 Added \u00b6 Ability to use custom program exit status codes via ProgramResult . inputStream and outputStream conversions for options and arguments. ( #157 and #159 ) splitPair , toMap , and associate extensions on option . ( #166 ) treatUnknownOptionsAsArgs parameter to CliktCommand . ( #152 ) defaultByName function for groupChoice and groupSwitch options. ( #171 ) Changed \u00b6 Update Kotlin to 1.3.71 Improved command name inference. Now, a class like MyAppCommand will infer its commandName as my-app rather than myappcommand . You can still specify the name manually as before. ([#168][ https://github.com/ajalt/clikt/pull/168 ]) Fixed \u00b6 Correctly parse short options with attached values that contain = 2.6.0 \u00b6 Added \u00b6 registeredSubcommands , registeredOptions , registeredArguments , and registeredParameterGroups methods on CliktCommand . Ability to read default option values from configuration files and other sources. Support for Java property files is built in on JVM, see the json sample for an example of reading from other formats. allowMultipleSubcommands parameter to CliktCommand that allows you to pass multiple subcommands in the same call. ( docs ) Errors from typos in subcommand names will now include suggested corrections. Corrections for options and subcommands are now based on a Jaro-Winkler similarity metric, and can be customized with Context.correctionSuggestor Changed \u00b6 Update Kotlin to 1.3.70 convert can be called more than once on the same option or argument, including after calls to conversion functions like int and file . CliktCommand.toString now includes the class name Reverted automatic ~ expansion in file() and path() introduced in 2.5.0. If you need this behavior, you can implement it with code like convert { /* expand tidle */ }.file() Deprecated \u00b6 wrapValue is now deprecated, since convert can be used in its place instead. 2.5.0 \u00b6 Added \u00b6 Clikt is now available as a Kotlin Multiplatform Project, supporting JVM, NodeJS, and native Windows, Linux, and macOS. eagerOption {} function to more easily register eager options. Eager options can now be added to option groups in help out by passing a value for groupName when creating them. canBeSymlink parameter to file() and path() conversions that can be used to disallow symlinks CliktCommand.eagerOption to simplify creating custom eager options Changed \u00b6 The parameter names of file() and path() conversions have changed. The existing names are deprecated, and can be converted to the new usages with an IntelliJ inspection. Note that if you are calling these functions with unnamed arguments (e.g. file(true, false) ), you\u2019ll need to add argument names in order to remove the deprecation warning. Deprecated \u00b6 The CliktCommand.context property has been deprecated in favor of the new name, currentContext , to avoid confusion with the CliktCommand.context{} method. NoRunCliktCommand was renamed to NoOpCliktCommand . The existing class is deprecated. ( #130 ) Fixed \u00b6 file() and path() conversions will now properly expand leading ~ in paths to the home directory for mustExist , canBeFile , and canBeDir checks. The property value is unchanged, and can still begin with a ~ . ( #131 ) 2.4.0 \u00b6 Added \u00b6 CompletionCandidates.Fixed now has a secondary convenience constructor that take a vararg of String s CompletionCadidates.Custom , which allows you to call other binaries or write a script to generate completions. This class is currently experimental. ( #79 ) Option.wrapValue and Argument.wrapValue to make it easier to reuse existing conversion functions. ignoreCase parameter to choice() and enum() conversion functions. Changed \u00b6 option() and argument() now take optional completionCandidates parameters to override how completion is generated. The constructor and copy functions of OptionsWithValues and ProcessedArgument have changed to support default values. The overloads of findObject ( 1 2 ) that take a default value have been renamed findOrSetObject . The existing names are marked with @Deprecated , and IntelliJ can convert your callsites automatically. ( #110 ) enum() parameters now accept case-insensitive values by default. You change this behavior by passing ignoreCase = false to enum() ( #115 ) Fixed \u00b6 groupChoice help output now includes the choices in the help output metavar TermUi.edit* functions could freeze on certain editors ( #99 , thanks @iampravikant and @sebokopter) Shell completion can now handle command names with dashes. ( #104 ) Arguments with = in them could be incorrectly interpreted as options ( #106 ) 2.3.0 \u00b6 Added \u00b6 option().groupSwitch() , which works like groupChoice() , but uses a switch() option rather than a choice() option. UsageError now has a statusCode parameter (which defaults to 1). If you\u2019re using ClicktCommand.main , the value of statusCode will be passed to exitProcess . Changed \u00b6 Shell completion code is now printed by throwing a PrintCompletionMessage (a subclass of PrintMessage ) rather than calling echo directly. 2.2.0 \u00b6 Added \u00b6 Added enum() conversion for options and arguments. ( #84 ) Changed \u00b6 There are now several ways of preventing @-file expansion Fixed \u00b6 Help output missing items when no help text is specified. ( #85 ) Help output not grouping options in groups passed to groupChoice . ( #88 ) 2.1.0 \u00b6 Added \u00b6 Ability to prevent rewrapping individual paragraphs in help output. Added parameter required to Option.multiple() to require at least one instance of the option on the command line. Changed \u00b6 CliktCommand.toString() now includes the names and values of all parameters and subcommands. Fixed \u00b6 Create subcommand context when helpOptionNames is empty. ( #64 ) 2.0.0 \u00b6 Added \u00b6 Bash autocomplete script generation . A property named completionCandidates has been added to Argument and Option interfaces, and corresponding parameters have been added to the various implementation constructors, as well as the convert functions. You can use this to control the values autocomplete that will be suggested. option().split() , and the corresponding OptionWithValues.valueSplit . Marking options as deprecated with option().deprecated() You can manually set the pattern to split envvars on by passing a pattern to the envvarSplit parameter of option() Option groups , mutually exclusive groups , co-occurring groups , and choice options with groups Support for Command line argument files a.k.a \u201c@-files\u201d Changed \u00b6 If multiple -- tokens are present on the command line, all subsequent occurrences after the first are now parsed as positional arguments. Previously, subsequent -- tokens were skipped. The PlaintextHelpFormatter has been replaced with CliktHelpFormatter , which is more customizable. See the docs for more info, or the new sample for an example of customizing help output to use ANSI colors. Some of the properties and constructor parameters for OptionWithValues and ProcessedArgument have changed. The OptionDelegate interface has changed, and GroupableOption and ParameterHolder interfaces have been added to work with option groups. Parameter validation now occurs after all parameter delegates have set their values, so the lambdas passed to validate may reference other parameters. 1.7.0 \u00b6 Added \u00b6 printHelpOnEmptyArgs parameter to CliktCommand constructor. ( #41 ) Fixed \u00b6 Usage errors now correctly print subcommand names. ( #47 ) Arguments with multiple(required=true) now report an error if no argument is given on the command line. ( #36 ) 1.6.0 \u00b6 Added \u00b6 .multiple().unique() modifier for options and arguments. Fixed \u00b6 Support multi-line input when redirecting stdin 1.5.0 \u00b6 Added \u00b6 Ability to use alternate output streams rather than stdin and stdout by setting Context.console or by passing a console to TermUI functions. 1.4.0 \u00b6 Added \u00b6 path() type for parameter values Changed \u00b6 Clikt now targets JVM 8 bytecode Responses to TermUi.confirm() are now case-insensitive 1.3.0 \u00b6 Added \u00b6 defaultLazy extension for options and arguments Changed \u00b6 main now prints messages to stderr instead of stdout Fixed \u00b6 Parameter help messages are now wrapped more consistently 1.2.0 \u00b6 Added \u00b6 Default parameter to option().default() Changed \u00b6 Treat tokens with unknown prefixes as arguments (this makes it easier to pass in file paths without using -- ). 1.1.0 \u00b6 Added \u00b6 List<String> overloads to CliktCommand.parse and main err parameter to TermUi.echo error property to Abort","title":"Change Log"},{"location":"changelog/#350","text":"","title":"3.5.0"},{"location":"changelog/#added","text":"Added hidden parameter to CliktCommand , which will prevent the command from being displayed as a subcommand in help output ( #353 ) Publish artifacts for the macosArm64 target. Note that this target is not tested on CI. ( #352 )","title":"Added"},{"location":"changelog/#changed","text":"Default values for arguments will now be included in help output when showDefaultValues=true is set on your help formatter ( #357 )","title":"Changed"},{"location":"changelog/#fixed","text":"Fix flags and other options with defaults not being usable in mutuallyExclusiveOptions ( #349 ) Fix CompletionCommand generating completion for itself ( #355 )","title":"Fixed"},{"location":"changelog/#342","text":"","title":"3.4.2"},{"location":"changelog/#deprecated","text":"TermUi.echo , TermUi.prompt , and TermUi.confirm . Use the equivalent methods on CliktCommand instead. ( #344 )","title":"Deprecated"},{"location":"changelog/#341","text":"","title":"3.4.1"},{"location":"changelog/#added_1","text":"Publish JS artifacts with new IR compiler, in addition to the legacy format","title":"Added"},{"location":"changelog/#changed_1","text":"Updated Kotlin to 1.6.20","title":"Changed"},{"location":"changelog/#340","text":"","title":"3.4.0"},{"location":"changelog/#changed_2","text":"unique() now works with any option with a list type, not just multiple() options ( #332 ) Updated Kotlin to 1.6.10","title":"Changed"},{"location":"changelog/#fixed_1","text":"Fixed co-occurring option groups returning null when all options in the group are defined in environment variables ( #330 )","title":"Fixed"},{"location":"changelog/#330","text":"","title":"3.3.0"},{"location":"changelog/#added_2","text":"Added default parameter to argument().multiple() ( #305 ) Context.originalArgv that allows you to read the command line arguments from within a command\u2019s run ( #290 ) context { envarReader = {...} } to set a custom function to read from environment variables ( #299 )","title":"Added"},{"location":"changelog/#changed_3","text":"defaultLazy values can now reference other parameters, as long the referenced parameters do not also reference other parameters You can now call CliktCommand.context multiple times on the same command, and all builder blocks will be applied Validate values entered to a prompt option, and show another prompt if the validation fails ( #288 ) Updated kotlin to 1.5.31","title":"Changed"},{"location":"changelog/#fixed_2","text":"Report error when excess arguments are given to a command with allowMultipleSubcommands=true ( #303 )","title":"Fixed"},{"location":"changelog/#320","text":"","title":"3.2.0"},{"location":"changelog/#added_3","text":"InputStream.isCliktParameterDefaultStdin and OutputStream.isCliktParameterDefaultStdout to check if the streams returned from inputStream / outputStream options are proxying stdin/stdout ( #272 )","title":"Added"},{"location":"changelog/#changed_4","text":"Make parameters of mutuallyExclusiveOptions covariant to allow validation without explicit type annotations. ( #265 ) Updated kotlin to 1.5.0","title":"Changed"},{"location":"changelog/#fixed_3","text":"Reading from an option or argument property on a command that hasn\u2019t been invoked will now always throw an IllegalStateException","title":"Fixed"},{"location":"changelog/#310","text":"","title":"3.1.0"},{"location":"changelog/#added_4","text":"Added required() and defaultLazy() for nullable flag options like switch() . ( #240 ) Added support for generating autocomplete scripts for Fish shells ( #189 ) Added CompletionCommand and CliktCommand.completionOption() that will print an autocomplete script when invoked, as an alternative to using environment variables.","title":"Added"},{"location":"changelog/#changed_5","text":"Updated Kotlin to 1.4.21 @argfiles now allow line breaks in quoted values, which are included in the value verbatim. You can now end lines with \\ to concatenate them with the following line. ( #248 )","title":"Changed"},{"location":"changelog/#301","text":"","title":"3.0.1"},{"location":"changelog/#deprecated_1","text":"Deprecated calling echo with err or lineSeparator but no message .","title":"Deprecated"},{"location":"changelog/#300","text":"","title":"3.0.0"},{"location":"changelog/#added_5","text":"Clikt\u2019s JS target now supports both NodeJS and Browsers. ( #198 ) Default values for switch options are now shown in the help. Help text can be customized using the defaultForHelp argument, similar to normal options. ( #205 ) Added FlagOption.convert ( #208 ) Added ability to use unicode NEL character ( \\u0085 ) to manually break lines in help output ( #214 ) Added help(\"\") extension to options and arguments as an alternative to passing the help as an argument ( #207 ) Added valueSourceKey parameter to option Added check() extensions to options and arguments as an alternative to validate() Added prompt and confirm functions to CliktCommand that call the TermUi equivalents with the current console. Added echo() overload with no parameters to CliktCommand that prints a newline by itself. Added localization support. You can set an implementation of the Localization interface on your context with your translations. ( #227 )","title":"Added"},{"location":"changelog/#fixed_4","text":"Hidden options will no longer be suggested as possible typo corrections. ( #202 ) Options and Arguments with multiple(required=true) will now show as required in help output. ( #212 ) Multiple short lines in a help text paragraph no longer appear dedented ( #215 )","title":"Fixed"},{"location":"changelog/#changed_6","text":"Updated Kotlin to 1.4.0 Argument.help and Option.help properties have been renamed to argumentHelp and optionHelp , respectively. The help parameter names to option() and argument() are unchanged. commandHelp and commandHelpEpilog properties on CliktCommand are now open , so you can choose to override them instead of passing help and epilog to the constructor. Replaced MapValueSource.defaultKey with ValueSource.getKey() , which is more customizable. Option.metavar , Option.parameterHelp , OptionGroup.parameterHelp and Argument.parameterHelp properties are now functions. Changed constructor parameters of CliktHelpFormatter . Added localization and removed usageTitle , optionsTitle , argumentsTitle , commandsTitle , optionsMetavar , and commandMetavar . Those strings are now defined on equivalently named functions on Localization .","title":"Changed"},{"location":"changelog/#removed","text":"Removed envvarSplit parameter from option() and convert() . Option values from environment variables are no longer split automatically. ( #177 ) Removed public constructors from the following classes: ProcessedArgument , OptionWithValues , FlagOption , CoOccurringOptionGroup , ChoiceGroup , MutuallyExclusiveOptions . MissingParameter exception replaced with MissingOption and MissingArgument Removed Context.helpOptionMessage . Override Localization.helpOptionMessage and set it on your context instead.","title":"Removed"},{"location":"changelog/#deprecated_2","text":"@ExperimentalCompletionCandidates and @ExperimentalValueSourceApi annotations. These APIs no longer require an opt-in.","title":"Deprecated"},{"location":"changelog/#280","text":"","title":"2.8.0"},{"location":"changelog/#added_6","text":"Added error parameter to PrintMessage and PrintHelpMessage . When true , CliktCommand.main will exit with status code 1. ( #187 )","title":"Added"},{"location":"changelog/#changed_7","text":"When printHelpOnEmptyArgs is true and no arguments are present, or when invokeWithoutSubcommand is false and no subcommand is present, CliktCommand.main will now exit with status code 1 rather than 0. restrictTo now works with any Comparable value, not just Number . CliktCommand.main now accepts Array<out String> , not just Array<String> . ( #196 )","title":"Changed"},{"location":"changelog/#fixed_5","text":"Fixed option values being reset when calling multiple subcommands with allowMultipleSubcommands=true ( #190 )","title":"Fixed"},{"location":"changelog/#271","text":"","title":"2.7.1"},{"location":"changelog/#fixed_6","text":"Fixed NPE thrown in some cases when using defaultByName ( #179 )","title":"Fixed"},{"location":"changelog/#270","text":"","title":"2.7.0"},{"location":"changelog/#added_7","text":"Ability to use custom program exit status codes via ProgramResult . inputStream and outputStream conversions for options and arguments. ( #157 and #159 ) splitPair , toMap , and associate extensions on option . ( #166 ) treatUnknownOptionsAsArgs parameter to CliktCommand . ( #152 ) defaultByName function for groupChoice and groupSwitch options. ( #171 )","title":"Added"},{"location":"changelog/#changed_8","text":"Update Kotlin to 1.3.71 Improved command name inference. Now, a class like MyAppCommand will infer its commandName as my-app rather than myappcommand . You can still specify the name manually as before. ([#168][ https://github.com/ajalt/clikt/pull/168 ])","title":"Changed"},{"location":"changelog/#fixed_7","text":"Correctly parse short options with attached values that contain =","title":"Fixed"},{"location":"changelog/#260","text":"","title":"2.6.0"},{"location":"changelog/#added_8","text":"registeredSubcommands , registeredOptions , registeredArguments , and registeredParameterGroups methods on CliktCommand . Ability to read default option values from configuration files and other sources. Support for Java property files is built in on JVM, see the json sample for an example of reading from other formats. allowMultipleSubcommands parameter to CliktCommand that allows you to pass multiple subcommands in the same call. ( docs ) Errors from typos in subcommand names will now include suggested corrections. Corrections for options and subcommands are now based on a Jaro-Winkler similarity metric, and can be customized with Context.correctionSuggestor","title":"Added"},{"location":"changelog/#changed_9","text":"Update Kotlin to 1.3.70 convert can be called more than once on the same option or argument, including after calls to conversion functions like int and file . CliktCommand.toString now includes the class name Reverted automatic ~ expansion in file() and path() introduced in 2.5.0. If you need this behavior, you can implement it with code like convert { /* expand tidle */ }.file()","title":"Changed"},{"location":"changelog/#deprecated_3","text":"wrapValue is now deprecated, since convert can be used in its place instead.","title":"Deprecated"},{"location":"changelog/#250","text":"","title":"2.5.0"},{"location":"changelog/#added_9","text":"Clikt is now available as a Kotlin Multiplatform Project, supporting JVM, NodeJS, and native Windows, Linux, and macOS. eagerOption {} function to more easily register eager options. Eager options can now be added to option groups in help out by passing a value for groupName when creating them. canBeSymlink parameter to file() and path() conversions that can be used to disallow symlinks CliktCommand.eagerOption to simplify creating custom eager options","title":"Added"},{"location":"changelog/#changed_10","text":"The parameter names of file() and path() conversions have changed. The existing names are deprecated, and can be converted to the new usages with an IntelliJ inspection. Note that if you are calling these functions with unnamed arguments (e.g. file(true, false) ), you\u2019ll need to add argument names in order to remove the deprecation warning.","title":"Changed"},{"location":"changelog/#deprecated_4","text":"The CliktCommand.context property has been deprecated in favor of the new name, currentContext , to avoid confusion with the CliktCommand.context{} method. NoRunCliktCommand was renamed to NoOpCliktCommand . The existing class is deprecated. ( #130 )","title":"Deprecated"},{"location":"changelog/#fixed_8","text":"file() and path() conversions will now properly expand leading ~ in paths to the home directory for mustExist , canBeFile , and canBeDir checks. The property value is unchanged, and can still begin with a ~ . ( #131 )","title":"Fixed"},{"location":"changelog/#240","text":"","title":"2.4.0"},{"location":"changelog/#added_10","text":"CompletionCandidates.Fixed now has a secondary convenience constructor that take a vararg of String s CompletionCadidates.Custom , which allows you to call other binaries or write a script to generate completions. This class is currently experimental. ( #79 ) Option.wrapValue and Argument.wrapValue to make it easier to reuse existing conversion functions. ignoreCase parameter to choice() and enum() conversion functions.","title":"Added"},{"location":"changelog/#changed_11","text":"option() and argument() now take optional completionCandidates parameters to override how completion is generated. The constructor and copy functions of OptionsWithValues and ProcessedArgument have changed to support default values. The overloads of findObject ( 1 2 ) that take a default value have been renamed findOrSetObject . The existing names are marked with @Deprecated , and IntelliJ can convert your callsites automatically. ( #110 ) enum() parameters now accept case-insensitive values by default. You change this behavior by passing ignoreCase = false to enum() ( #115 )","title":"Changed"},{"location":"changelog/#fixed_9","text":"groupChoice help output now includes the choices in the help output metavar TermUi.edit* functions could freeze on certain editors ( #99 , thanks @iampravikant and @sebokopter) Shell completion can now handle command names with dashes. ( #104 ) Arguments with = in them could be incorrectly interpreted as options ( #106 )","title":"Fixed"},{"location":"changelog/#230","text":"","title":"2.3.0"},{"location":"changelog/#added_11","text":"option().groupSwitch() , which works like groupChoice() , but uses a switch() option rather than a choice() option. UsageError now has a statusCode parameter (which defaults to 1). If you\u2019re using ClicktCommand.main , the value of statusCode will be passed to exitProcess .","title":"Added"},{"location":"changelog/#changed_12","text":"Shell completion code is now printed by throwing a PrintCompletionMessage (a subclass of PrintMessage ) rather than calling echo directly.","title":"Changed"},{"location":"changelog/#220","text":"","title":"2.2.0"},{"location":"changelog/#added_12","text":"Added enum() conversion for options and arguments. ( #84 )","title":"Added"},{"location":"changelog/#changed_13","text":"There are now several ways of preventing @-file expansion","title":"Changed"},{"location":"changelog/#fixed_10","text":"Help output missing items when no help text is specified. ( #85 ) Help output not grouping options in groups passed to groupChoice . ( #88 )","title":"Fixed"},{"location":"changelog/#210","text":"","title":"2.1.0"},{"location":"changelog/#added_13","text":"Ability to prevent rewrapping individual paragraphs in help output. Added parameter required to Option.multiple() to require at least one instance of the option on the command line.","title":"Added"},{"location":"changelog/#changed_14","text":"CliktCommand.toString() now includes the names and values of all parameters and subcommands.","title":"Changed"},{"location":"changelog/#fixed_11","text":"Create subcommand context when helpOptionNames is empty. ( #64 )","title":"Fixed"},{"location":"changelog/#200","text":"","title":"2.0.0"},{"location":"changelog/#added_14","text":"Bash autocomplete script generation . A property named completionCandidates has been added to Argument and Option interfaces, and corresponding parameters have been added to the various implementation constructors, as well as the convert functions. You can use this to control the values autocomplete that will be suggested. option().split() , and the corresponding OptionWithValues.valueSplit . Marking options as deprecated with option().deprecated() You can manually set the pattern to split envvars on by passing a pattern to the envvarSplit parameter of option() Option groups , mutually exclusive groups , co-occurring groups , and choice options with groups Support for Command line argument files a.k.a \u201c@-files\u201d","title":"Added"},{"location":"changelog/#changed_15","text":"If multiple -- tokens are present on the command line, all subsequent occurrences after the first are now parsed as positional arguments. Previously, subsequent -- tokens were skipped. The PlaintextHelpFormatter has been replaced with CliktHelpFormatter , which is more customizable. See the docs for more info, or the new sample for an example of customizing help output to use ANSI colors. Some of the properties and constructor parameters for OptionWithValues and ProcessedArgument have changed. The OptionDelegate interface has changed, and GroupableOption and ParameterHolder interfaces have been added to work with option groups. Parameter validation now occurs after all parameter delegates have set their values, so the lambdas passed to validate may reference other parameters.","title":"Changed"},{"location":"changelog/#170","text":"","title":"1.7.0"},{"location":"changelog/#added_15","text":"printHelpOnEmptyArgs parameter to CliktCommand constructor. ( #41 )","title":"Added"},{"location":"changelog/#fixed_12","text":"Usage errors now correctly print subcommand names. ( #47 ) Arguments with multiple(required=true) now report an error if no argument is given on the command line. ( #36 )","title":"Fixed"},{"location":"changelog/#160","text":"","title":"1.6.0"},{"location":"changelog/#added_16","text":".multiple().unique() modifier for options and arguments.","title":"Added"},{"location":"changelog/#fixed_13","text":"Support multi-line input when redirecting stdin","title":"Fixed"},{"location":"changelog/#150","text":"","title":"1.5.0"},{"location":"changelog/#added_17","text":"Ability to use alternate output streams rather than stdin and stdout by setting Context.console or by passing a console to TermUI functions.","title":"Added"},{"location":"changelog/#140","text":"","title":"1.4.0"},{"location":"changelog/#added_18","text":"path() type for parameter values","title":"Added"},{"location":"changelog/#changed_16","text":"Clikt now targets JVM 8 bytecode Responses to TermUi.confirm() are now case-insensitive","title":"Changed"},{"location":"changelog/#130","text":"","title":"1.3.0"},{"location":"changelog/#added_19","text":"defaultLazy extension for options and arguments","title":"Added"},{"location":"changelog/#changed_17","text":"main now prints messages to stderr instead of stdout","title":"Changed"},{"location":"changelog/#fixed_14","text":"Parameter help messages are now wrapped more consistently","title":"Fixed"},{"location":"changelog/#120","text":"","title":"1.2.0"},{"location":"changelog/#added_20","text":"Default parameter to option().default()","title":"Added"},{"location":"changelog/#changed_18","text":"Treat tokens with unknown prefixes as arguments (this makes it easier to pass in file paths without using -- ).","title":"Changed"},{"location":"changelog/#110","text":"","title":"1.1.0"},{"location":"changelog/#added_21","text":"List<String> overloads to CliktCommand.parse and main err parameter to TermUi.echo error property to Abort","title":"Added"},{"location":"commands/","text":"Commands \u00b6 Clikt supports arbitrarily nested commands. You can add one command as a child of another with the subcommands function, which can be called either in an init block, or on an existing instance. Executing Nested Commands \u00b6 For commands with no children, run is called whenever the command line is parsed (unless parsing is aborted from an error or an option like --help ). If a command has children, this isn\u2019t the case. Instead, its run is called only if a child command is invoked, just before the subcommand\u2019s run . If a parent command is called without specifying a subcommand, the help page is printed and run is not called. Example class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) override fun run () { echo ( \"Verbose mode is ${ if ( verbose ) \" on \" else \" off \" } \" ) } } class Execute : CliktCommand () { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage 1 $ ./tool Usage: tool [OPTIONS] COMMAND [ARGS]... Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Usage 2 $ ./tool --verbose execute Verbose mode is on executing Customizing Command Name \u00b6 The default name for subcommands is inferred as a lowercase name from the command class name. You can also set a name manually in the CliktCommand constructor. Example class Tool : CliktCommand () { override fun run () = Unit } class Execute : CliktCommand ( name = \"RUN-ME\" ) { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage 1 $ ./tool RUN-ME executing Usage 2 $ ./tool -h Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: RUN-ME Passing Parameters \u00b6 When calling subcommands, the position of options and arguments on the command line affect which command will parse them. A parameter is parsed by a command if it occurs after the command name, but before any other command names. Example class Tool : CliktCommand ( help = \"A tool that runs\" ) { val verbose by option (). flag ( \"--no-verbose\" ) override fun run () = Unit } class Execute : CliktCommand ( help = \"Execute the command\" ) { val name by option () override fun run () = Unit } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... A tool that runs Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Execute the command If you instead execute --help after the subcommand, the subcommand\u2019s help is printed: $ ./tool execute --help Usage: execute [OPTIONS] Execute the command Options: --name TEXT -h, --help Show this message and exit But executing ./tool --help execute , with the option before the subcommand, will cause the parent\u2019s help option to be invoked, printing out Tool \u2018s help page as if you just typed ./tool --help . Nested Handling And Contexts \u00b6 Normally nested command are independent of each other: a child can\u2019t access its parent\u2019s parameters. This makes composing commands much easier, but what if you want to pass information to a child command? You can do so with the command\u2019s Context . Every time the command line is parsed, each command creates a new context object for itself that is linked to its parent\u2019s context. Context objects have a number of properties that can be used to customize command line parsing. Although each command creates its own context, the configuration is inherited from the parent context. Context objects also have an obj property that can hold an object that can be accessed from child commands. Example class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) val config by findOrSetObject { mutableMapOf < String , String > () } override fun run () { config [ \"VERBOSE\" ] = if ( verbose ) \"on\" else \"off\" } } class Execute : CliktCommand () { val config by requireObject < Map < String , String >> () override fun run () { echo ( \"Verbose mode is ${ config [ \" VERBOSE \" ] } \" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage $ ./tool --verbose execute Verbose mode is on The findObject , findOrSetObject , and requireObject functions will walk up the context tree until they find a obj with the given type. If no such object exists, they will either return null , throw an exception, or create an instance of the object and store it on the command\u2019s context, depending on which function you use. Since each context only has a single obj , if you need to store multiple objects on a single context, you could create a data class with everything you want to store and set that as your obj . Note that the findOrSetObject property is lazy and won\u2019t set the Context\u2019s obj until its value is accessed. If you need to set an object for subcommands without accessing the property, you should use currentContext.findOrSetObject , or set currentContext.obj directly, instead. Eager initialization with findOrSetObject class Tool : CliktCommand () { override fun run () { // runs eagerly currentContext . findOrSetObject { MyConfig () } } } Eager initialization with currentContext.obj class Tool : CliktCommand () { override fun run () { // runs eagerly, won't look for parent contexts currentContext . obj = MyConfig () } } Running Parent Command Without Children \u00b6 Normally, if a command has children, run is not called unless a child command is invoked on the command line. Instead, --help is called on the parent. If you want to change this behavior to always call run() on the parent, you can do so by setting invokeWithoutSubcommand to true . The Context will then have information on the subcommand that is about to be invoked, if there is one. Example class Tool : CliktCommand ( invokeWithoutSubcommand = true ) { override fun run () { val subcommand = currentContext . invokedSubcommand if ( subcommand == null ) { echo ( \"invoked without a subcommand\" ) } else { echo ( \"about to run ${ subcommand . commandName } \" ) } } } class Execute : CliktCommand () { override fun run () { echo ( \"running subcommand\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage 1 $ ./tool invoked without a subcommand Usage 2 $./tool execute about to run execute running subcommand Customizing Contexts \u00b6 Contexts have a number of properties that can be customized, and which are inherited by child commands. You can change these properties with the context builder function, which can be called in an init block, or on a command instance. For example, you can change the name of help option. These definitions are equivalent: Version 1 class Cli : NoOpCliktCommand () { init { context { helpOptionNames = setOf ( \"/help\" ) } } } fun main ( args : Array < String > ) = Cli () Version 2 class Cli : NoOpCliktCommand () fun main ( args : Array < String > ) = Cli () . context { helpOptionNames = setOf ( \"/help\" ) } . main ( args ) Usage $ ./cli --help Usage: cli [OPTIONS] Options: -h, --help print the help Printing the Help Message When No Arguments Are Given \u00b6 Normally, if a command is called with no values on the command line, a usage error is printed if there are required parameters, or run is called if there aren\u2019t any. You can change this behavior by passing printHelpOnEmptyArgs = true to your command\u2019s constructor. This will cause a help message to be printed when no values are provided on the command line, regardless of the parameters in your command. Example class Cli : CliktCommand ( printHelpOnEmptyArgs = true ) { val arg by argument () override fun run () { echo ( \"Command ran\" ) } } Usage $ ./cli Usage: cli [OPTIONS] Options: -h, --help print the help Warnings and Other Messages \u00b6 When you want to show information to the user, you\u2019ll usually want to use the functions for printing to stdout directly. However, there\u2019s another mechanism that can be useful when writing reusable parameter code: command messages. These messages are buffered during parsing and printed all at once immediately before a command\u2019s run is called. They are not printed if there are any errors in parsing. This type of message is used by Clikt for deprecating options . You can issue a command message by calling CliktCommand.issueMessage or with the message function available in the context of parameter transformers. Example class Cli : CliktCommand () { // This will print the warning when the option is given, but not if there are errors val opt by option (). validate { if ( it . isEmpty ()) message ( \"Empty strings are not recommended\" ) } override fun run () { echo ( \"command run\" ) } } Usage 1 $ ./cli --opt='' Empty strings are not recommended command run Usage 2 $ ./cli --opt='' --oops Error: no such option: \"--oops\". You can disable automatic message printing on the command\u2019s context : Example class Cli : CliktCommand () { init { context { printExtraMessages = false } } val opt by option (). validate { if ( it . isEmpty ()) message ( \"Empty strings are not recommended\" ) } override fun run () { echo ( \"command run\" ) } } Usage $ ./cli --opt='' command run Chaining and Repeating Subcommands \u00b6 Some command line interfaces allow you to call more than one subcommand at a time. For example, you might do something like gradle clean build publish to run the clean task, then the build task, then the publish task, which are all subcommands of gradle . To do this with Clikt, pass allowMultipleSubcommands = true to your CliktCommand constructor. Example class Compiler : CliktCommand ( allowMultipleSubcommands = true ) { override fun run () { echo ( \"Running compiler\" ) } } class Clean : CliktCommand () { val force by option (). flag () override fun run () { echo ( \"Cleaning (force= $ force )\" ) } } class Build : CliktCommand () { val file by argument (). file () override fun run () { echo ( \"Building $ file \" ) } } fun main ( args : Array < String > ) = Compiler (). subcommands ( Clean (), Build ()). main ( args ) Usage $ ./compiler clean --force build main.kt Running compiler Cleaning (force=true) Building main.kt The parent command will run once, and each subcommand will run once each time they\u2019re called. Parsing multiple subcommands \u00b6 Note that enabling allowMultipleSubcommands will disable allowInterspersedArgs on the command and all its subcommands. If both were allowed to be enabled at the same time, then not all command lines could be parsed unambiguously. When parsing in this mode, tokens are consumed greedily by a subcommand until it encounters an argument token it doesn\u2019t support, at which point the parent command resumes parsing where the subcommand left off. This means that if you have a subcommand with an argument().multiple() parameter, you won\u2019t be able to call any other subcommands after that one, since it will consume the rest of the command line. Subcommands of a command with allowMultipleSubcommands=true can themselves have subcommands, but cannot have allowMultipleSubcommands=true .","title":"Executing Nested Commands"},{"location":"commands/#commands","text":"Clikt supports arbitrarily nested commands. You can add one command as a child of another with the subcommands function, which can be called either in an init block, or on an existing instance.","title":"Commands"},{"location":"commands/#executing-nested-commands","text":"For commands with no children, run is called whenever the command line is parsed (unless parsing is aborted from an error or an option like --help ). If a command has children, this isn\u2019t the case. Instead, its run is called only if a child command is invoked, just before the subcommand\u2019s run . If a parent command is called without specifying a subcommand, the help page is printed and run is not called. Example class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) override fun run () { echo ( \"Verbose mode is ${ if ( verbose ) \" on \" else \" off \" } \" ) } } class Execute : CliktCommand () { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage 1 $ ./tool Usage: tool [OPTIONS] COMMAND [ARGS]... Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Usage 2 $ ./tool --verbose execute Verbose mode is on executing","title":"Executing Nested Commands"},{"location":"commands/#customizing-command-name","text":"The default name for subcommands is inferred as a lowercase name from the command class name. You can also set a name manually in the CliktCommand constructor. Example class Tool : CliktCommand () { override fun run () = Unit } class Execute : CliktCommand ( name = \"RUN-ME\" ) { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage 1 $ ./tool RUN-ME executing Usage 2 $ ./tool -h Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: RUN-ME","title":"Customizing Command Name"},{"location":"commands/#passing-parameters","text":"When calling subcommands, the position of options and arguments on the command line affect which command will parse them. A parameter is parsed by a command if it occurs after the command name, but before any other command names. Example class Tool : CliktCommand ( help = \"A tool that runs\" ) { val verbose by option (). flag ( \"--no-verbose\" ) override fun run () = Unit } class Execute : CliktCommand ( help = \"Execute the command\" ) { val name by option () override fun run () = Unit } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... A tool that runs Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Execute the command If you instead execute --help after the subcommand, the subcommand\u2019s help is printed: $ ./tool execute --help Usage: execute [OPTIONS] Execute the command Options: --name TEXT -h, --help Show this message and exit But executing ./tool --help execute , with the option before the subcommand, will cause the parent\u2019s help option to be invoked, printing out Tool \u2018s help page as if you just typed ./tool --help .","title":"Passing Parameters"},{"location":"commands/#nested-handling-and-contexts","text":"Normally nested command are independent of each other: a child can\u2019t access its parent\u2019s parameters. This makes composing commands much easier, but what if you want to pass information to a child command? You can do so with the command\u2019s Context . Every time the command line is parsed, each command creates a new context object for itself that is linked to its parent\u2019s context. Context objects have a number of properties that can be used to customize command line parsing. Although each command creates its own context, the configuration is inherited from the parent context. Context objects also have an obj property that can hold an object that can be accessed from child commands. Example class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) val config by findOrSetObject { mutableMapOf < String , String > () } override fun run () { config [ \"VERBOSE\" ] = if ( verbose ) \"on\" else \"off\" } } class Execute : CliktCommand () { val config by requireObject < Map < String , String >> () override fun run () { echo ( \"Verbose mode is ${ config [ \" VERBOSE \" ] } \" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage $ ./tool --verbose execute Verbose mode is on The findObject , findOrSetObject , and requireObject functions will walk up the context tree until they find a obj with the given type. If no such object exists, they will either return null , throw an exception, or create an instance of the object and store it on the command\u2019s context, depending on which function you use. Since each context only has a single obj , if you need to store multiple objects on a single context, you could create a data class with everything you want to store and set that as your obj . Note that the findOrSetObject property is lazy and won\u2019t set the Context\u2019s obj until its value is accessed. If you need to set an object for subcommands without accessing the property, you should use currentContext.findOrSetObject , or set currentContext.obj directly, instead. Eager initialization with findOrSetObject class Tool : CliktCommand () { override fun run () { // runs eagerly currentContext . findOrSetObject { MyConfig () } } } Eager initialization with currentContext.obj class Tool : CliktCommand () { override fun run () { // runs eagerly, won't look for parent contexts currentContext . obj = MyConfig () } }","title":"Nested Handling And Contexts"},{"location":"commands/#running-parent-command-without-children","text":"Normally, if a command has children, run is not called unless a child command is invoked on the command line. Instead, --help is called on the parent. If you want to change this behavior to always call run() on the parent, you can do so by setting invokeWithoutSubcommand to true . The Context will then have information on the subcommand that is about to be invoked, if there is one. Example class Tool : CliktCommand ( invokeWithoutSubcommand = true ) { override fun run () { val subcommand = currentContext . invokedSubcommand if ( subcommand == null ) { echo ( \"invoked without a subcommand\" ) } else { echo ( \"about to run ${ subcommand . commandName } \" ) } } } class Execute : CliktCommand () { override fun run () { echo ( \"running subcommand\" ) } } fun main ( args : Array < String > ) = Tool (). subcommands ( Execute ()). main ( args ) Usage 1 $ ./tool invoked without a subcommand Usage 2 $./tool execute about to run execute running subcommand","title":"Running Parent Command Without Children"},{"location":"commands/#customizing-contexts","text":"Contexts have a number of properties that can be customized, and which are inherited by child commands. You can change these properties with the context builder function, which can be called in an init block, or on a command instance. For example, you can change the name of help option. These definitions are equivalent: Version 1 class Cli : NoOpCliktCommand () { init { context { helpOptionNames = setOf ( \"/help\" ) } } } fun main ( args : Array < String > ) = Cli () Version 2 class Cli : NoOpCliktCommand () fun main ( args : Array < String > ) = Cli () . context { helpOptionNames = setOf ( \"/help\" ) } . main ( args ) Usage $ ./cli --help Usage: cli [OPTIONS] Options: -h, --help print the help","title":"Customizing Contexts"},{"location":"commands/#printing-the-help-message-when-no-arguments-are-given","text":"Normally, if a command is called with no values on the command line, a usage error is printed if there are required parameters, or run is called if there aren\u2019t any. You can change this behavior by passing printHelpOnEmptyArgs = true to your command\u2019s constructor. This will cause a help message to be printed when no values are provided on the command line, regardless of the parameters in your command. Example class Cli : CliktCommand ( printHelpOnEmptyArgs = true ) { val arg by argument () override fun run () { echo ( \"Command ran\" ) } } Usage $ ./cli Usage: cli [OPTIONS] Options: -h, --help print the help","title":"Printing the Help Message When No Arguments Are Given"},{"location":"commands/#warnings-and-other-messages","text":"When you want to show information to the user, you\u2019ll usually want to use the functions for printing to stdout directly. However, there\u2019s another mechanism that can be useful when writing reusable parameter code: command messages. These messages are buffered during parsing and printed all at once immediately before a command\u2019s run is called. They are not printed if there are any errors in parsing. This type of message is used by Clikt for deprecating options . You can issue a command message by calling CliktCommand.issueMessage or with the message function available in the context of parameter transformers. Example class Cli : CliktCommand () { // This will print the warning when the option is given, but not if there are errors val opt by option (). validate { if ( it . isEmpty ()) message ( \"Empty strings are not recommended\" ) } override fun run () { echo ( \"command run\" ) } } Usage 1 $ ./cli --opt='' Empty strings are not recommended command run Usage 2 $ ./cli --opt='' --oops Error: no such option: \"--oops\". You can disable automatic message printing on the command\u2019s context : Example class Cli : CliktCommand () { init { context { printExtraMessages = false } } val opt by option (). validate { if ( it . isEmpty ()) message ( \"Empty strings are not recommended\" ) } override fun run () { echo ( \"command run\" ) } } Usage $ ./cli --opt='' command run","title":"Warnings and Other Messages"},{"location":"commands/#chaining-and-repeating-subcommands","text":"Some command line interfaces allow you to call more than one subcommand at a time. For example, you might do something like gradle clean build publish to run the clean task, then the build task, then the publish task, which are all subcommands of gradle . To do this with Clikt, pass allowMultipleSubcommands = true to your CliktCommand constructor. Example class Compiler : CliktCommand ( allowMultipleSubcommands = true ) { override fun run () { echo ( \"Running compiler\" ) } } class Clean : CliktCommand () { val force by option (). flag () override fun run () { echo ( \"Cleaning (force= $ force )\" ) } } class Build : CliktCommand () { val file by argument (). file () override fun run () { echo ( \"Building $ file \" ) } } fun main ( args : Array < String > ) = Compiler (). subcommands ( Clean (), Build ()). main ( args ) Usage $ ./compiler clean --force build main.kt Running compiler Cleaning (force=true) Building main.kt The parent command will run once, and each subcommand will run once each time they\u2019re called.","title":"Chaining and Repeating Subcommands"},{"location":"commands/#parsing-multiple-subcommands","text":"Note that enabling allowMultipleSubcommands will disable allowInterspersedArgs on the command and all its subcommands. If both were allowed to be enabled at the same time, then not all command lines could be parsed unambiguously. When parsing in this mode, tokens are consumed greedily by a subcommand until it encounters an argument token it doesn\u2019t support, at which point the parent command resumes parsing where the subcommand left off. This means that if you have a subcommand with an argument().multiple() parameter, you won\u2019t be able to call any other subcommands after that one, since it will consume the rest of the command line. Subcommands of a command with allowMultipleSubcommands=true can themselves have subcommands, but cannot have allowMultipleSubcommands=true .","title":"Parsing multiple subcommands"},{"location":"documenting/","text":"Documenting Scripts \u00b6 Clikt takes care of creating formatted help messages for commands. There are a number of ways to customize the default behavior. You can also implement your own HelpFormatter and set it on the command\u2019s context . Help Texts \u00b6 Commands and parameters accept a help argument. Commands also accept an epilog argument, which is printed after the parameters and commands on the help page. All text is automatically trimmed of leading indentation and re-wrapped to the terminal width. As an alternative to passing your help strings as function arguments, you can also use the help() extensions for your options, and override commandHelp and commandHelpEpilog on your commands. Example class Hello : CliktCommand ( help = \"\"\" This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. \"\"\" ) { val count by option ( \"-c\" , \"--count\" , metavar = \"COUNT\" , help = \"number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () = repeat ( count ) { echo ( \"Hello $ name !\" ) } } Alternate style class Hello : CliktCommand () { override val commandHelp = \"\"\" This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. \"\"\" val count by option ( \"-c\" , \"--count\" , metavar = \"COUNT\" ). int (). default ( 1 ) . help ( \"number of greetings\" ) val name by argument () override fun run () = repeat ( count ) { echo ( \"Hello $ name !\" ) } } Help output $ ./hello --help Usage: hello [OPTIONS] NAME This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. Options: -c, --count COUNT number of greetings -h, --help Show this message and exit Option names and metavars will appear in help output even if no help string is specified for them. On the other hand, arguments only appear in the usage string. It is possible to add a help string to arguments which will be added to the help page, but the Unix convention is to just describe arguments in the command help. Preformatting Paragraphs \u00b6 By default, Clikt will rewrap all paragraphs in your text to the terminal width. This can be undesirable if you have some preformatted text, such as source code or a bulleted list. You can preformat a paragraph by surrounding it with markdown-style triple backticks. The backticks will be removed from the output, and if the backticks are on a line by themselves, the line will be removed. All whitespace and newlines in the paragraph will be preserved, and will be be rewrapped. Example class Tool : NoOpCliktCommand ( help = \"\"\"This is my command. This paragraph will be wrapped, but the following list will not: ``` - This is a list - Its newlines will remain intact ``` This is a new paragraph that will be wrapped if it's wider than the teminal width. \"\"\" ) Help output Usage: tool This is my command. This paragraph will be wrapped, but the following list will not: - This is a list - It's newlines will remain intact This is a new paragraph that will be wrapped if it's wider than the terminal width. Options: -h, --help Show this message and exit Manual Line Breaks \u00b6 If you want to insert a line break manually without preformmating the entire paragraph, you can use the Unicode Next Line (NEL) character . You can type a NEL with the unicode literal \\u0085 . Clikt will treat NEL similarly to how <br> behaves in HTML: The NEL will be replaced with a line break in the output, and the paragraph will still be wrapped to the terminal width. Example class Tool : NoOpCliktCommand () { val option by option ( help = \"This help will be at least two lines.\\u0085(this will start a new line)\" ) } Help output Usage: tool Options: --option This help will be at least two lines. (this will start a new line) -h, --help Show this message and exit Subcommand Short Help \u00b6 Subcommands are listed in the help page based on their name . They have a short help string which is the first line of their help. Example class Tool : NoOpCliktCommand () class Execute : NoOpCliktCommand ( help = \"\"\" Execute the command. The command will be executed. \"\"\" ) class Abort : NoOpCliktCommand ( help = \"Kill any running commands.\" ) Usage $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: execute Execute the command. abort Kill any running commands. Help Option Customization \u00b6 Clikt handles the help option is specially. It is added automatically to every command. Any help option name that conflicts with another option is not used for the help option. If the help option has no unique names, it is not added. You can change the help option\u2019s name and help message on the command\u2019s context : Example class HelpLocalization : Localization { override fun helpOptionMessage (): String = \"show the help\" } class Tool : NoOpCliktCommand () { init { context { helpOptionNames = setOf ( \"/help\" ) localization = HelpLocalization () } } } Usage $ ./tool /help Usage: tool [OPTIONS] Options: /help show the help If you don\u2019t want a help option to be added, you can set helpOptionNames = emptySet() Default Values in Help \u00b6 You can configure the help formatter to show default values in the help output by passing showDefaultValues = true to the CliktHelpFormatter . By default, the string value of the default value will be shown. You can show a different value by passing the value you want to show to the defaultForHelp parameter of default . Example class Tool : NoOpCliktCommand () { init { context { helpFormatter = CliktHelpFormatter ( showDefaultValues = true ) } } val a by option ( help = \"this is optional\" ). default ( \"value\" ) val b by option ( help = \"this is also optional\" ). default ( \"value\" , defaultForHelp = \"chosen for you\" ) } Usage $ ./tool --help Usage: tool [OPTIONS] Options: --a TEXT this is optional (default: value) --b TEXT this is also optional (default: chosen for you) Required Options in Help \u00b6 By default, required options are displayed the same way as other options. The help formatter includes two different ways to show that an option is required. Required Option Marker \u00b6 You can pass a character to the requiredOptionMarker argument of the CliktHelpFormatter . Example class Tool : NoOpCliktCommand () { init { context { helpFormatter = CliktHelpFormatter ( requiredOptionMarker = \"*\" ) } } val option by option ( help = \"this is optional\" ) val required by option ( help = \"this is required\" ). required () } Usage $ ./tool --help Usage: tool [OPTIONS] Options: --option TEXT this is optional * --required TEXT this is required -h, --help Show this message and exit Required Option Tag \u00b6 You can also show a tag for required options by passing showRequiredTag = true to the CliktHelpFormatter . Example class Tool : CliktCommand () { init { context { helpFormatter = CliktHelpFormatter ( showRequiredTag = true ) } } val option by option ( help = \"this is optional\" ) val required by option ( help = \"this is required\" ). required () } Usage $ ./tool --help Usage: tool [OPTIONS] Options: --option TEXT this is optional --required TEXT this is required (required) -h, --help Show this message and exit Grouping Options in Help \u00b6 You can group options into separate help sections by using OptionGroup and importing groups.provideDelegate . The name of the group will be shown in the output. You can also add an extra help message to be shown with the group. Groups can\u2019t be nested. Example import com.github.ajalt.clikt.parameters.groups.provideDelegate class UserOptions : OptionGroup ( name = \"User Options\" , help = \"Options controlling the user\" ) { val name by option ( help = \"user name\" ) val age by option ( help = \"user age\" ). int () } class Tool : NoOpCliktCommand () { val userOptions by UserOptions () } Usage $ ./tool --help Usage: cli [OPTIONS] User Options: Options controlling the user --name TEXT user name --age INT user age Options: -h, --help Show this message and exit Suggesting Corrections for Mistyped Parameters \u00b6 When an option or subcommand is mistyped, Clikt will suggest corrections that are similar to the typed value. Mistyped Option $ ./cli --sise=5 Error: no such option: \"--sise\". Did you mean \"--size\"? Mistyped Subcommand $ ./cli building Usage: cli [OPTIONS] COMMAND [ARGS]... Error: no such subcommand: \"building\". Did you mean \"build\"? By default, Clikt will suggest corrections of any similar option or subcommand name based on a similarity metric. You can customize the suggestions by setting a correctionSuggestor on your command\u2019s context. class Cli : NoOpCliktCommand () { init { context { // Only suggest corrections that start with the entered value correctionSuggestor = { enteredValue , possibleValues -> possibleValues . filter { it . startsWith ( enteredValue ) } } } } } Localization \u00b6 You can localize error messages by implementing Localization and setting the localization property on your context. Example class CursiveLocalization : Localization { override fun usageTitle () = \"\ud835\udcb0\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52:\" override fun optionsTitle () = \"\ud835\udcaa\ud835\udcc5\ud835\udcc9\ud835\udcbe\ud835\udc5c\ud835\udcc3\ud835\udcc8:\" override fun optionsMetavar () = \"[\ud835\udcaa\ud835\udcab\ud835\udcaf\ud835\udc3c\ud835\udcaa\ud835\udca9\ud835\udcae]:\" override fun helpOptionMessage () = \"\ud835\udcae\ud835\udcbd\ud835\udc5c\ud835\udccc \ud835\udcc9\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc2\ud835\udc52\ud835\udcc8\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52 \ud835\udcb6\ud835\udcc3\ud835\udcb9 \ud835\udc52\ud835\udccd\ud835\udcbe\ud835\udcc9\" // ... override the rest of the strings here } class I18NTool : NoOpCliktCommand ( help = \"\ud835\udcaf\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc9\ud835\udc5c\ud835\udc5c\ud835\udcc1 \ud835\udcbe\ud835\udcc8 \ud835\udcbe\ud835\udcc3 \ud835\udcb8\ud835\udcca\ud835\udcc7\ud835\udcc8\ud835\udcbe\ud835\udccb\ud835\udc52\" ) { init { context { localization = CursiveLocalization () } } } Usage $ ./i18ntool --help \ud835\udcb0\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52: i18ntool [\ud835\udcaa\ud835\udcab\ud835\udcaf\ud835\udc3c\ud835\udcaa\ud835\udca9\ud835\udcae] \ud835\udcaf\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc9\ud835\udc5c\ud835\udc5c\ud835\udcc1 \ud835\udcbe\ud835\udcc8 \ud835\udcbe\ud835\udcc3 \ud835\udcb8\ud835\udcca\ud835\udcc7\ud835\udcc8\ud835\udcbe\ud835\udccb\ud835\udc52 \ud835\udcaa\ud835\udcc5\ud835\udcc9\ud835\udcbe\ud835\udc5c\ud835\udcc3\ud835\udcc8: -h, --help \ud835\udcae\ud835\udcbd\ud835\udc5c\ud835\udccc \ud835\udcc9\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc2\ud835\udc52\ud835\udcc8\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52 \ud835\udcb6\ud835\udcc3\ud835\udcb9 \ud835\udc52\ud835\udccd\ud835\udcbe\ud835\udcc9","title":"Help Texts"},{"location":"documenting/#documenting-scripts","text":"Clikt takes care of creating formatted help messages for commands. There are a number of ways to customize the default behavior. You can also implement your own HelpFormatter and set it on the command\u2019s context .","title":"Documenting Scripts"},{"location":"documenting/#help-texts","text":"Commands and parameters accept a help argument. Commands also accept an epilog argument, which is printed after the parameters and commands on the help page. All text is automatically trimmed of leading indentation and re-wrapped to the terminal width. As an alternative to passing your help strings as function arguments, you can also use the help() extensions for your options, and override commandHelp and commandHelpEpilog on your commands. Example class Hello : CliktCommand ( help = \"\"\" This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. \"\"\" ) { val count by option ( \"-c\" , \"--count\" , metavar = \"COUNT\" , help = \"number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () = repeat ( count ) { echo ( \"Hello $ name !\" ) } } Alternate style class Hello : CliktCommand () { override val commandHelp = \"\"\" This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. \"\"\" val count by option ( \"-c\" , \"--count\" , metavar = \"COUNT\" ). int (). default ( 1 ) . help ( \"number of greetings\" ) val name by argument () override fun run () = repeat ( count ) { echo ( \"Hello $ name !\" ) } } Help output $ ./hello --help Usage: hello [OPTIONS] NAME This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. Options: -c, --count COUNT number of greetings -h, --help Show this message and exit Option names and metavars will appear in help output even if no help string is specified for them. On the other hand, arguments only appear in the usage string. It is possible to add a help string to arguments which will be added to the help page, but the Unix convention is to just describe arguments in the command help.","title":"Help Texts"},{"location":"documenting/#preformatting-paragraphs","text":"By default, Clikt will rewrap all paragraphs in your text to the terminal width. This can be undesirable if you have some preformatted text, such as source code or a bulleted list. You can preformat a paragraph by surrounding it with markdown-style triple backticks. The backticks will be removed from the output, and if the backticks are on a line by themselves, the line will be removed. All whitespace and newlines in the paragraph will be preserved, and will be be rewrapped. Example class Tool : NoOpCliktCommand ( help = \"\"\"This is my command. This paragraph will be wrapped, but the following list will not: ``` - This is a list - Its newlines will remain intact ``` This is a new paragraph that will be wrapped if it's wider than the teminal width. \"\"\" ) Help output Usage: tool This is my command. This paragraph will be wrapped, but the following list will not: - This is a list - It's newlines will remain intact This is a new paragraph that will be wrapped if it's wider than the terminal width. Options: -h, --help Show this message and exit","title":"Preformatting Paragraphs"},{"location":"documenting/#manual-line-breaks","text":"If you want to insert a line break manually without preformmating the entire paragraph, you can use the Unicode Next Line (NEL) character . You can type a NEL with the unicode literal \\u0085 . Clikt will treat NEL similarly to how <br> behaves in HTML: The NEL will be replaced with a line break in the output, and the paragraph will still be wrapped to the terminal width. Example class Tool : NoOpCliktCommand () { val option by option ( help = \"This help will be at least two lines.\\u0085(this will start a new line)\" ) } Help output Usage: tool Options: --option This help will be at least two lines. (this will start a new line) -h, --help Show this message and exit","title":"Manual Line Breaks"},{"location":"documenting/#subcommand-short-help","text":"Subcommands are listed in the help page based on their name . They have a short help string which is the first line of their help. Example class Tool : NoOpCliktCommand () class Execute : NoOpCliktCommand ( help = \"\"\" Execute the command. The command will be executed. \"\"\" ) class Abort : NoOpCliktCommand ( help = \"Kill any running commands.\" ) Usage $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: execute Execute the command. abort Kill any running commands.","title":"Subcommand Short Help"},{"location":"documenting/#help-option-customization","text":"Clikt handles the help option is specially. It is added automatically to every command. Any help option name that conflicts with another option is not used for the help option. If the help option has no unique names, it is not added. You can change the help option\u2019s name and help message on the command\u2019s context : Example class HelpLocalization : Localization { override fun helpOptionMessage (): String = \"show the help\" } class Tool : NoOpCliktCommand () { init { context { helpOptionNames = setOf ( \"/help\" ) localization = HelpLocalization () } } } Usage $ ./tool /help Usage: tool [OPTIONS] Options: /help show the help If you don\u2019t want a help option to be added, you can set helpOptionNames = emptySet()","title":"Help Option Customization"},{"location":"documenting/#default-values-in-help","text":"You can configure the help formatter to show default values in the help output by passing showDefaultValues = true to the CliktHelpFormatter . By default, the string value of the default value will be shown. You can show a different value by passing the value you want to show to the defaultForHelp parameter of default . Example class Tool : NoOpCliktCommand () { init { context { helpFormatter = CliktHelpFormatter ( showDefaultValues = true ) } } val a by option ( help = \"this is optional\" ). default ( \"value\" ) val b by option ( help = \"this is also optional\" ). default ( \"value\" , defaultForHelp = \"chosen for you\" ) } Usage $ ./tool --help Usage: tool [OPTIONS] Options: --a TEXT this is optional (default: value) --b TEXT this is also optional (default: chosen for you)","title":"Default Values in Help"},{"location":"documenting/#required-options-in-help","text":"By default, required options are displayed the same way as other options. The help formatter includes two different ways to show that an option is required.","title":"Required Options in Help"},{"location":"documenting/#required-option-marker","text":"You can pass a character to the requiredOptionMarker argument of the CliktHelpFormatter . Example class Tool : NoOpCliktCommand () { init { context { helpFormatter = CliktHelpFormatter ( requiredOptionMarker = \"*\" ) } } val option by option ( help = \"this is optional\" ) val required by option ( help = \"this is required\" ). required () } Usage $ ./tool --help Usage: tool [OPTIONS] Options: --option TEXT this is optional * --required TEXT this is required -h, --help Show this message and exit","title":"Required Option Marker"},{"location":"documenting/#required-option-tag","text":"You can also show a tag for required options by passing showRequiredTag = true to the CliktHelpFormatter . Example class Tool : CliktCommand () { init { context { helpFormatter = CliktHelpFormatter ( showRequiredTag = true ) } } val option by option ( help = \"this is optional\" ) val required by option ( help = \"this is required\" ). required () } Usage $ ./tool --help Usage: tool [OPTIONS] Options: --option TEXT this is optional --required TEXT this is required (required) -h, --help Show this message and exit","title":"Required Option Tag"},{"location":"documenting/#grouping-options-in-help","text":"You can group options into separate help sections by using OptionGroup and importing groups.provideDelegate . The name of the group will be shown in the output. You can also add an extra help message to be shown with the group. Groups can\u2019t be nested. Example import com.github.ajalt.clikt.parameters.groups.provideDelegate class UserOptions : OptionGroup ( name = \"User Options\" , help = \"Options controlling the user\" ) { val name by option ( help = \"user name\" ) val age by option ( help = \"user age\" ). int () } class Tool : NoOpCliktCommand () { val userOptions by UserOptions () } Usage $ ./tool --help Usage: cli [OPTIONS] User Options: Options controlling the user --name TEXT user name --age INT user age Options: -h, --help Show this message and exit","title":"Grouping Options in Help"},{"location":"documenting/#suggesting-corrections-for-mistyped-parameters","text":"When an option or subcommand is mistyped, Clikt will suggest corrections that are similar to the typed value. Mistyped Option $ ./cli --sise=5 Error: no such option: \"--sise\". Did you mean \"--size\"? Mistyped Subcommand $ ./cli building Usage: cli [OPTIONS] COMMAND [ARGS]... Error: no such subcommand: \"building\". Did you mean \"build\"? By default, Clikt will suggest corrections of any similar option or subcommand name based on a similarity metric. You can customize the suggestions by setting a correctionSuggestor on your command\u2019s context. class Cli : NoOpCliktCommand () { init { context { // Only suggest corrections that start with the entered value correctionSuggestor = { enteredValue , possibleValues -> possibleValues . filter { it . startsWith ( enteredValue ) } } } } }","title":"Suggesting Corrections for Mistyped Parameters"},{"location":"documenting/#localization","text":"You can localize error messages by implementing Localization and setting the localization property on your context. Example class CursiveLocalization : Localization { override fun usageTitle () = \"\ud835\udcb0\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52:\" override fun optionsTitle () = \"\ud835\udcaa\ud835\udcc5\ud835\udcc9\ud835\udcbe\ud835\udc5c\ud835\udcc3\ud835\udcc8:\" override fun optionsMetavar () = \"[\ud835\udcaa\ud835\udcab\ud835\udcaf\ud835\udc3c\ud835\udcaa\ud835\udca9\ud835\udcae]:\" override fun helpOptionMessage () = \"\ud835\udcae\ud835\udcbd\ud835\udc5c\ud835\udccc \ud835\udcc9\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc2\ud835\udc52\ud835\udcc8\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52 \ud835\udcb6\ud835\udcc3\ud835\udcb9 \ud835\udc52\ud835\udccd\ud835\udcbe\ud835\udcc9\" // ... override the rest of the strings here } class I18NTool : NoOpCliktCommand ( help = \"\ud835\udcaf\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc9\ud835\udc5c\ud835\udc5c\ud835\udcc1 \ud835\udcbe\ud835\udcc8 \ud835\udcbe\ud835\udcc3 \ud835\udcb8\ud835\udcca\ud835\udcc7\ud835\udcc8\ud835\udcbe\ud835\udccb\ud835\udc52\" ) { init { context { localization = CursiveLocalization () } } } Usage $ ./i18ntool --help \ud835\udcb0\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52: i18ntool [\ud835\udcaa\ud835\udcab\ud835\udcaf\ud835\udc3c\ud835\udcaa\ud835\udca9\ud835\udcae] \ud835\udcaf\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc9\ud835\udc5c\ud835\udc5c\ud835\udcc1 \ud835\udcbe\ud835\udcc8 \ud835\udcbe\ud835\udcc3 \ud835\udcb8\ud835\udcca\ud835\udcc7\ud835\udcc8\ud835\udcbe\ud835\udccb\ud835\udc52 \ud835\udcaa\ud835\udcc5\ud835\udcc9\ud835\udcbe\ud835\udc5c\ud835\udcc3\ud835\udcc8: -h, --help \ud835\udcae\ud835\udcbd\ud835\udc5c\ud835\udccc \ud835\udcc9\ud835\udcbd\ud835\udcbe\ud835\udcc8 \ud835\udcc2\ud835\udc52\ud835\udcc8\ud835\udcc8\ud835\udcb6\ud835\udc54\ud835\udc52 \ud835\udcb6\ud835\udcc3\ud835\udcb9 \ud835\udc52\ud835\udccd\ud835\udcbe\ud835\udcc9","title":"Localization"},{"location":"exceptions/","text":"Exception Handling \u00b6 Clikt uses exceptions internally to signal that processing has ended early for any reason. This includes incorrect command line usage, or printing a help page. Where are Exceptions Handled? \u00b6 When you call CliktCommand.main , it will parse the command line and catch any CliktError and Abort exceptions. If it catches one, it will then print out the appropriate information and exit the process. If the caught exception is a PrintMessage or PrintHelpMessage , the process exit status will be 0 and the message will be printed to stdout. Otherwise it will exit with status 1 and print the message to stderr. Any other types of exceptions indicate a programming error, and are not caught by main . However, convert and the other parameter transformations will wrap exceptions thrown inside them in a UsageError , so if you define a custom transformation, you don\u2019t have to worry about an exception escaping to the user. Handling Exceptions Manually \u00b6 CliktCommand.main is just a try / catch block surrounding CliktCommand.parse , so if don\u2019t want exceptions to be caught, you can call parse wherever you would normally call main . fun main ( args : Array < String > ) = Cli (). parse ( args ) Which Exceptions Exist? \u00b6 Clikt will throw Abort if it needs to halt execution immediately without a specific message. All other exceptions are subclasses of UsageError . The following subclasses exist: PrintMessage : The exception\u2019s message should be printed. PrintHelpMessage : The help page for the exception\u2019s command should be printed. PrintCompletionMessage : Shell completion code for the command should be printed. UsageError : The command line was incorrect in some way. All other exceptions subclass from this. These exceptions are automatically augmented with extra information about the current parameter, if possible. ProgramResult : The program should exit with the statusCode from this exception. BadParameterValue : A parameter was given the correct number of values, but of invalid format or type. MissingOption and MissingArgument : A required parameter was not provided. NoSuchOption : An option was provided that does not exist. NoSuchSubcommand : A subcommand was called that does not exist. IncorrectOptionValueCount : An option was supplied but the number of values supplied to the option was incorrect. IncorrectArgumentValueCount : An argument was supplied but the number of values supplied was incorrect. MutuallyExclusiveGroupException : Multiple options in a mutually exclusive group were supplied when the group is restricted to a single value. FileNotFound : A required configuration file or @-file was not found. InvalidFileFormat : A configuration file or @-file failed to parse correctly.","title":"Where are Exceptions Handled?"},{"location":"exceptions/#exception-handling","text":"Clikt uses exceptions internally to signal that processing has ended early for any reason. This includes incorrect command line usage, or printing a help page.","title":"Exception Handling"},{"location":"exceptions/#where-are-exceptions-handled","text":"When you call CliktCommand.main , it will parse the command line and catch any CliktError and Abort exceptions. If it catches one, it will then print out the appropriate information and exit the process. If the caught exception is a PrintMessage or PrintHelpMessage , the process exit status will be 0 and the message will be printed to stdout. Otherwise it will exit with status 1 and print the message to stderr. Any other types of exceptions indicate a programming error, and are not caught by main . However, convert and the other parameter transformations will wrap exceptions thrown inside them in a UsageError , so if you define a custom transformation, you don\u2019t have to worry about an exception escaping to the user.","title":"Where are Exceptions Handled?"},{"location":"exceptions/#handling-exceptions-manually","text":"CliktCommand.main is just a try / catch block surrounding CliktCommand.parse , so if don\u2019t want exceptions to be caught, you can call parse wherever you would normally call main . fun main ( args : Array < String > ) = Cli (). parse ( args )","title":"Handling Exceptions Manually"},{"location":"exceptions/#which-exceptions-exist","text":"Clikt will throw Abort if it needs to halt execution immediately without a specific message. All other exceptions are subclasses of UsageError . The following subclasses exist: PrintMessage : The exception\u2019s message should be printed. PrintHelpMessage : The help page for the exception\u2019s command should be printed. PrintCompletionMessage : Shell completion code for the command should be printed. UsageError : The command line was incorrect in some way. All other exceptions subclass from this. These exceptions are automatically augmented with extra information about the current parameter, if possible. ProgramResult : The program should exit with the statusCode from this exception. BadParameterValue : A parameter was given the correct number of values, but of invalid format or type. MissingOption and MissingArgument : A required parameter was not provided. NoSuchOption : An option was provided that does not exist. NoSuchSubcommand : A subcommand was called that does not exist. IncorrectOptionValueCount : An option was supplied but the number of values supplied to the option was incorrect. IncorrectArgumentValueCount : An argument was supplied but the number of values supplied was incorrect. MutuallyExclusiveGroupException : Multiple options in a mutually exclusive group were supplied when the group is restricted to a single value. FileNotFound : A required configuration file or @-file was not found. InvalidFileFormat : A configuration file or @-file failed to parse correctly.","title":"Which Exceptions Exist?"},{"location":"migration/","text":"Upgrading to Newer Releases \u00b6 Upgrading to 3.0 \u00b6 Maven Coordinates \u00b6 Clikt\u2019s Maven groupId changed from com.github.ajalt to com.github.ajalt.clikt . So the full coordinate is now com.github.ajalt.clikt:clikt:3.0.0 . With the new Multiplatform plugin in Kotlin 1.4, there is no longer a separate clikt-multiplatform artifact. You can use com.github.ajalt.clikt:clikt:3.0.0 for both JVM-only and Multiplatform projects. Environment variable splitting \u00b6 There used to be an envvarSplit parameter to option() and its convert() that would split values coming from an environment variable. This parameter is removed, and values from environment variables are no longer split automatically. If you still want to split option values, you can do so explicitly with split() . Experimental APIs \u00b6 The Value Source API and Completion Generation APIs no longer require opt-in. You can use these APIs without needing the ExperimentalValueSourceApi or ExperimentalCompletionCandidates annotations. Localization \u00b6 By default, all strings are defined in the Localization object set on your [context][ Context.localization . This means that string parameters like usageTitle in the constructor for CliktHelpFormatter have been removed in favor of functions like Localization.usageTitle() . Context.helpOptionMessage has also been removed in favor of Localization.helpOptionMessage() . See Help Option Customization for an example.","title":"Upgrading to Newer Releases"},{"location":"migration/#upgrading-to-newer-releases","text":"","title":"Upgrading to Newer Releases"},{"location":"migration/#upgrading-to-30","text":"","title":"Upgrading to 3.0"},{"location":"migration/#maven-coordinates","text":"Clikt\u2019s Maven groupId changed from com.github.ajalt to com.github.ajalt.clikt . So the full coordinate is now com.github.ajalt.clikt:clikt:3.0.0 . With the new Multiplatform plugin in Kotlin 1.4, there is no longer a separate clikt-multiplatform artifact. You can use com.github.ajalt.clikt:clikt:3.0.0 for both JVM-only and Multiplatform projects.","title":"Maven Coordinates"},{"location":"migration/#environment-variable-splitting","text":"There used to be an envvarSplit parameter to option() and its convert() that would split values coming from an environment variable. This parameter is removed, and values from environment variables are no longer split automatically. If you still want to split option values, you can do so explicitly with split() .","title":"Environment variable splitting"},{"location":"migration/#experimental-apis","text":"The Value Source API and Completion Generation APIs no longer require opt-in. You can use these APIs without needing the ExperimentalValueSourceApi or ExperimentalCompletionCandidates annotations.","title":"Experimental APIs"},{"location":"migration/#localization","text":"By default, all strings are defined in the Localization object set on your [context][ Context.localization . This means that string parameters like usageTitle in the constructor for CliktHelpFormatter have been removed in favor of functions like Localization.usageTitle() . Context.helpOptionMessage has also been removed in favor of Localization.helpOptionMessage() . See Help Option Customization for an example.","title":"Localization"},{"location":"options/","text":"Options \u00b6 Options are added to commands by defining a property delegate with the option function. Basic Options \u00b6 The default option takes one value of type String . The property is nullable. If the option is not given on the command line, the property value will be null. If the option is given at least once, the property will return the value of the last occurrence of the option. Example class Hello : CliktCommand () { val name by option ( help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Usage $ ./hello --name=Foo Hello, Foo! Option Names \u00b6 If you don\u2019t specify names for an option, a lowercase hyphen-separated name is automatically inferred from the property. For example, val myOpt by option() will create an option that can be called with --my-opt . You can also specify any number of names for an option manually: class Hello : CliktCommand () { val name by option ( \"-n\" , \"--name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Option names that are two characters long (like -n ) are treated as POSIX-style short options. You call them with a value like this: Usage 1 $ ./hello -nfoo Hello, foo! Usage 2 $ ./hello -n foo Hello, foo! All other option names are considered long options, and can be called like this: Usage 1 $ ./hello --name=foo Hello, foo! Usage 2 $ ./hello --name foo Hello, foo! Customizing Options \u00b6 The option behavior and delegate type can be customized by calling extension functions on the option call. For example, here are some different option declarations: val a : String? by option () val b : Int? by option (). int () val c : Pair < Int , Int >? by option (). int (). pair () val d : Pair < Int , Int > by option (). int (). pair (). default ( 0 to 0 ) val e : Pair < Float , Float > by option (). float (). pair (). default ( 0f to 0f ) There are three main types of behavior that can be customized independently: The type of each value in the option. The value type is String by default, but can be customized with built-in functions like int or choice , or manually with convert . This is detailed in the parameters page. The number of values that the option requires. Options take one value by default, but this can be changed with built-in functions like pair and triple , or manually with transformValues . How to handle all calls to the option (i.e. if the option is not present, or is present more than once). By default, the option delegate value is the null if the option is not given on the command line, and will use the value of the last occurrence if the option is given more than once. You can change this behavior with functions like default and multiple . Since the three types of customizations are orthogonal, you can choose which ones you want to use, and if you implement a new customization, it can be used with all of the existing functions without any repeated code. Default Values \u00b6 By default, option delegates return null if the option wasn\u2019t provided on the command line. You can instead return a default value with default . Example class Pow : CliktCommand () { val exp by option ( \"-e\" , \"--exp\" ). double (). default ( 1.0 ) override fun run () { echo ( \"2 ^ $ exp = ${ ( 2.0 ). pow ( exp ) } \" ) } } Usage 1 $ ./pow -e 8 2 ^ 8.0 = 256.0 Usage 2 $ ./pow 2 ^ 1.0 = 2.0 If the default value is expensive to compute, or you want to use another parameter as the default, you can use defaultLazy instead of default . It has the same effect, but you give it a lambda returning the default value, and the lambda will only be called if the option isn\u2019t present on the command line. Multi Value Options \u00b6 Options can take any fixed number of values separated by whitespace, or a variable number of values separated by a non-whitespace delimiter you specify. If you want a variable number of values separated by whitespace, you need to use an argument instead. Options With Fixed Number of Values \u00b6 There are built in functions for options that take two values ( pair , which uses a Pair ), or three values ( triple , which uses a Triple ). You can change the type of each value as normal with functions like int . If you need more values, you can provide your own container with transformValues . You give that function the number of values you want, and a lambda that will transform a list of values into the output container. The list will always have a size equal to the number you specify. If the user provides a different number of values, Clikt will inform the user and your lambda won\u2019t be called. Example data class Quad < out T > ( val a : T , val b : T , val c : T , val d : T ) fun < T > Quad < T > . toList (): List < T > = listOf ( a , b , c , d ) class Geometry : CliktCommand () { val square by option (). int (). pair () val cube by option (). int (). triple () val tesseract by option (). int (). transformValues ( 4 ) { Quad ( it [ 0 ] , it [ 1 ] , it [ 2 ] , it [ 3 ] ) } override fun run () { echo ( \"Square has dimensions ${ square ?. toList () ?. joinToString ( \" x \" ) } \" ) echo ( \"Cube has dimensions ${ cube ?. toList () ?. joinToString ( \" x \" ) } \" ) echo ( \"Tesseract has dimensions ${ tesseract ?. toList () ?. joinToString ( \" x \" ) } \" ) } } Usage $ ./geometry --square 1 2 --cube 3 4 5 --tesseract 6 7 8 9 Square has dimensions 1x2 Cube has dimensions 3x4x5 Tesseract has dimensions 6x7x8x9 Options With a Variable Number of Values \u00b6 You can use split to allow a variable number of values to a single option invocation by separating the values with non-whitespace delimiters. This will also split values from environment variables . Example class C : CliktCommand () { val profiles by option ( \"-P\" , envvar = \"PROFILES\" ). split ( \",\" ) override fun run () { for ( profile in profiles ) { echo ( profile ) } } } Usage $ ./split -P profile-1,profile-2 profile-1 profile-2 Usage with Environment Variable $ export PROFILES=profile-1,profile-2 $ ./split profile-1 profile-2 Multiple Options \u00b6 Normally, when an option is provided on the command line more than once, only the values from the last occurrence are used. But sometimes you want to keep all values provided. For example, git commit -m foo -m bar would create a commit message with two lines: foo and bar . To get this behavior with Clikt, you can use multiple . This will cause the property delegate value to be a list, where each item in the list is the value of from one occurrence of the option. If the option is never given, the list will be empty (or you can specify a default to use). Example class Commit : CliktCommand () { val message : List < String > by option ( \"-m\" ). multiple () override fun run () { echo ( message . joinToString ( \"\\n\" )) } } Usage $ ./commit -m foo -m bar foo bar You can combine multiple with item type conversions and multiple values. val opt : List < Pair < Int , Int >> by option (). int (). pair (). multiple () Default values for option().multiple() \u00b6 You can also supply a default value to multiple or require at least one value be present on the command line. These are specified as arguments rather than with separate extension functions since they don\u2019t change the type of the delegate. Required val opt : List < String > by option (). multiple ( required = true ) Default val opt : List < String > by option (). multiple ( default = listOf ( \"default message\" )) Deduplicating option().multiple() into a unique set \u00b6 You can discard duplicate values from a multiple option with unique . Example class Build : CliktCommand () { val platforms : Set < String > by option ( \"-p\" ). multiple (). unique () override fun run () { echo ( \"Building for platforms: $ platforms \" ) } } Usage $ ./build -p android -p ios -p android Building for platforms: [android, ios] Key-Value and Map Options \u00b6 You can split an option\u2019s value into a key-value pair with splitPair . By default, the delimiter = will be used to split. You can also use associate to allow the option to be specified multiple times, and have its values collected in a map. Example class Build : CliktCommand () { val systemProp : Map < String , String > by option ( \"-D\" , \"--system-prop\" ). associate () override fun run () { echo ( systemProp ) } } Usage $ ./build -Dplace=here --system-prop size=small {place=here, size=small} Boolean Flag Options \u00b6 Flags are options that don\u2019t take a value. Boolean flags can be enabled or disabled, depending on the name used to invoke the option. You can turn an option into a boolean flag with flag . That function takes an optional list of secondary names that will be added to any existing or inferred names for the option. If the option is invoked with one of the secondary names, the delegate will return false. It\u2019s a good idea to always set secondary names so that a user can disable the flag if it was enabled previously. Example class Cli : CliktCommand () { val flag by option ( \"--on\" , \"-o\" ). flag ( \"--off\" , \"-O\" , default = false ) override fun run () { echo ( flag ) } } Usage 1 $ ./cli -o true Usage 2 $ ./cli --on --off false Multiple short flag options can be combined when called on the command line: Example class Cli : CliktCommand () { val flagA by option ( \"-a\" ). flag () val flagB by option ( \"-b\" ). flag () val foo by option ( \"-f\" ) override fun run () { echo ( \" $ flagA $ flagB $ foo \" ) } } Usage $ ./cli -abfFoo true true Foo Counted Flag Options \u00b6 You might want a flag option that counts the number of times it occurs on the command line. You can use counted for this. Example class Log : CliktCommand () { val verbosity by option ( \"-v\" ). counted () override fun run () { echo ( \"Verbosity level: $ verbosity \" ) } } Usage $ ./log -vvv Verbosity level: 3 Feature Switch Flags \u00b6 Another way to use flags is to assign a value to each option name. You can do this with switch , which takes a map of option names to values. Note that the names in the map replace any previously specified or inferred names. Example class Size : CliktCommand () { val size by option (). switch ( \"--large\" to \"large\" , \"--small\" to \"small\" ). default ( \"unknown\" ) override fun run () { echo ( \"You picked size $ size \" ) } } Usage $ ./size --small You picked size small Choice Options \u00b6 You can restrict the values that a regular option can take to a set of values using choice . You can also map the input values to new types. Example class Digest : CliktCommand () { val hash by option (). choice ( \"md5\" , \"sha1\" ) override fun run () { echo ( hash ) } } Usage 1 $ ./digest --hash=md5 md5 Usage 2 $ ./digest --hash=sha256 Usage: digest [OPTIONS] Error: Invalid value for \"--hash\": invalid choice: sha256. (choose from md5, sha1) Usage 3 $ ./digest --help Usage: digest [OPTIONS] Options: --hash [md5|sha1] -h, --help Show this message and exit Mutually Exclusive Option Groups \u00b6 If choice or switch options aren\u2019t flexible enough, you can use mutuallyExclusiveOptions to group any nullable options into a mutually exclusive group. If more than one of the options in the group is given on the command line, the last value is used. If you want different types for each option, you can wrap them in a sealed class. Example sealed class Fruit { data class Oranges ( val size : String ): Fruit () data class Apples ( val count : Int ): Fruit () } class Order : CliktCommand () { val fruit : Fruit? by mutuallyExclusiveOptions < Fruit > ( option ( \"--oranges\" ). convert { Oranges ( it ) }, option ( \"--apples\" ). int (). convert { Apples ( it ) } ) override fun run () = echo ( fruit ) } Usage 1 $ ./order --apples=10 Apples(count=10) Usage 2 $ ./order --oranges=small Oranges(size=small) Usage 3 $ ./order --apples=10 --oranges=large Oranges(size=large) You can enforce that only one of the options is given with single : Example val fruit : Fruit? by mutuallyExclusiveOptions < Fruit > ( option ( \"--apples\" ). convert { Apples ( it . toInt ()) }, option ( \"--oranges\" ). convert { Oranges ( it ) } ). single () Usage $ ./order --apples=10 --oranges=small Usage: order [OPTIONS] Error: option --apples cannot be used with --oranges Like regular options, you can make the entire group required , or give it a default value. Like other option groups , you can specify a name and help text for the group if you want to set the group apart in the help output. Co-Occurring Option Groups \u00b6 Sometimes you have a set of options that only make sense when specified together. To enforce this, you can make an option group cooccurring . Co-occurring groups must have at least one required option, and may also have non-required options. The required constraint is enforced if any of the options in the group are given on the command line. If none if the options are given, the value of the group is null. Example class UserOptions : OptionGroup () { val name by option (). required () val age by option (). int () } class Tool : CliktCommand () { val userOptions by UserOptions (). cooccurring () override fun run () { userOptions ?. let { echo ( it . name ) echo ( it . age ) } ?: echo ( \"No user options\" ) } } Usage 1 $ ./tool No user options Usage 2 $ ./tool --name=jane --age=30 jane 30 Usage 3 $ ./tool --age=30 Usage: tool [OPTIONS] Error: Missing option \"--name\". Like other option groups , you can specify a name and help text for the group if you want to set the group apart in the help output. Choice and Switch Options With Groups \u00b6 If you have different groups of options that only make sense when another option has a certain value, you can use groupChoice and groupSwitch . groupChoice options are similar to choice options , but instead of mapping a value to a single new type, they map a value to a co-occurring OptionGroup . Options for groups other than the selected one are ignored, and only the selected group\u2019s required constraints are enforced. In the same way, groupSwitch options are similar to switch options . Example sealed class LoadConfig ( name : String ): OptionGroup ( name ) class FromDisk : LoadConfig ( \"Options for loading from disk\" ) { val path by option (). file (). required () val followSymlinks by option (). flag () } class FromNetwork : LoadConfig ( \"Options for loading from network\" ) { val url by option (). required () val username by option (). prompt () val password by option (). prompt ( hideInput = true ) } class Tool : CliktCommand ( help = \"An example of a custom help formatter that uses ansi colors\" ) { val load by option (). groupChoice ( \"disk\" to FromDisk (), \"network\" to FromNetwork () ) override fun run () { when ( val it = load ) { is FromDisk -> echo ( \"Loading from disk: ${ it . path } \" ) is FromNetwork -> echo ( \"Loading from network: ${ it . url } \" ) null -> echo ( \"Not loading\" ) } } } Usage 1 $ ./tool --load=disk --path=./config --follow-symlinks Loading from disk: .\\config Usage 2 $ ./tool --load=network --url=www.example.com --username=admin Password: ******* Loading from network: www.example.com Usage 3 $ ./tool --load=disk Usage: cli [OPTIONS] Error: Missing option \"--path\". Usage 4 $ ./tool --load=whoops Usage: cli [OPTIONS] Error: Invalid value for \"--load\": invalid choice: whoops. (choose from disk, network) Prompting For Input \u00b6 In some cases, you might want to create an option that uses the value given on the command line if there is one, but prompt the user for input if one is not provided. Clikt can take care of this for you with the prompt function. Example class Hello : CliktCommand () { val name by option (). prompt () override fun run () { echo ( \"Hello $ name \" ) } } Usage 1 ./hello --name=foo Hello foo Usage 2 ./hello Name: foo Hello foo The default prompt string is based on the option name, but prompt takes a number of parameters to customize the output. Password Prompts \u00b6 You can also create a option that uses a hidden prompt and asks for confirmation. This combination of behavior is commonly used for passwords. Example class Login : CliktCommand () { val password by option (). prompt ( requireConfirmation = true , hideInput = true ) override fun run () { echo ( \"Your hidden password: $ password \" ) } } Usage $ ./login Password: Repeat for confirmation: Your hidden password: hunter2 Eager Options \u00b6 Sometimes you want an option to halt execution immediately and print a message. For example, the built-on --help option, or the --version option that many programs have. Neither of these options have any value associated with them, and they stop command line parsing as soon as they\u2019re encountered. The --help option is added automatically to commands, and --version can be added using versionOption . Since the option doesn\u2019t have a value, you can\u2019t define it using a property delegate. Instead, call the function on a command directly, either in an init block, or on a command instance. These definitions are equivalent: Version 1 class Cli : NoOpCliktCommand () { init { versionOption ( \"1.0\" ) } } fun main ( args : Array < String > ) = Cli (). main ( args ) Version 2 class Cli : NoOpCliktCommand () fun main ( args : Array < String > ) = Cli (). versionOption ( \"1.0\" ). main ( args ) Usage $ ./cli --version cli version 1.0 If you want to define your own option with a similar behavior, you can do so by calling eagerOption . This function takes an action that is called when the option is encountered on the command line. To print a message and halt execution normally from the callback, you can throw a PrintMessage exception, and CliktCommand.main will take care of printing the message. If you want to exit normally without printing a message, you can throw Abort(error=false) instead. You can define your own version option like this: class Cli : NoOpCliktCommand () { init { eagerOption ( \"--version\" ) { throw PrintMessage ( \" $ commandName version 1.0\" ) } } } Deprecating Options \u00b6 You can communicate to users that an option is deprecated with option().deprecated() . By default, this function will add a tag to the option\u2019s help message, and print a warning to stderr if the option is used. You can customize or omit the warning message and help tags, or change the warning into an error. Example class Cli : CliktCommand () { val opt by option ( help = \"option 1\" ). deprecated () val opt2 by option ( help = \"option 2\" ). deprecated ( \"WARNING: --opt2 is deprecated, use --new-opt instead\" , tagName = null ) val opt3 by option ( help = \"option 3\" ). deprecated ( tagName = \"pending deprecation\" , tagValue = \"use --new-opt instead\" ) val opt4 by option ( help = \"option 4\" ). deprecated ( error = true ) override fun run () = echo ( \"command run\" ) } Usage 1 $ ./cli --opt=x WARNING: option --opt is deprecated command run Usage 2 $ ./cli --opt2=x WARNING: --op2 is deprecated, use --new-opt instead command run Usage 3 $ ./cli --opt3=x WARNING: option --opt3 is deprecated command run Usage 4 $ ./cli --opt4=x ERROR: option --opt4 is deprecated Help Output $ ./cli --help Usage: cli [OPTIONS] Options: --opt TEXT option 1 (deprecated) --opt2 TEXT option 2 --opt3 TEXT option 3 (pending deprecation: use --new-opt instead) --opt4 TEXT option 4 (deprecated) Unknown Options \u00b6 You may want to collect unknown options for manual processing. You can do this by passing treatUnknownOptionsAsArgs = true to your CliktCommand constructor . This will cause Clikt to treat unknown options as positional arguments rather than reporting an error when one is encountered. You\u2019ll need to define an argument().multiple() property to collect the options, otherwise an error will still be reported. Example class Wrapper : CliktCommand ( treatUnknownOptionsAsArgs = true ) { init { context { allowInterspersedArgs = false } } val command by option ( help = \"?\" ). required () val arguments by argument (). multiple () override fun run () { val cmd = ( listOf ( command ) + arguments ). joinToString ( \" \" ) val proc = Runtime . getRuntime (). exec ( cmd ) println ( proc . inputStream . bufferedReader (). readText ()) proc . waitFor () } } Usage $ ./wrapper --command=git tag --help | head -n4 GIT-TAG(1) Git Manual GIT-TAG(1) NAME git-tag - Create, list, delete or verify a tag object signed with GPG Note that flag options in a single token (e.g. using -abc to specify -a , -b , and -c in a single token) will still report an error if they are unknown. Each option should be specified separately in this mode. You\u2019ll often want to set allowInterspersedArgs = false on your Context when using treatUnknownOptionsAsArgs . You may also find that subcommands are a better fit than treatUnknownOptionsAsArgs for your use case. Values From Environment Variables \u00b6 Clikt supports reading option values from environment variables if they aren\u2019t given on the command line. This feature is helpful when automating tools. For example, when using git commit , you can set the author date with a command line parameter: git commit --date=10/21/2015 . But you can also set it with an environment variable: GIT_AUTHOR_DATE=10/21/2015 git commit . Clikt will read option values from environment variables as long as it has an envvar name for the option. There are two ways to set that name: you can set the name manually for an option, or you can enable automatic envvar name inference. To set the envvar name manually, pass the name to option : Example class Hello : CliktCommand () { val name by option ( envvar = \"MY_NAME\" ) override fun run () { echo ( \"Hello $ name \" ) } } Usage 1 $ export MY_NAME=Foo $ ./hello Hello Foo Usage 2 $ export MY_NAME=Foo $ ./hello --name=Bar Hello Bar You can enable automatic envvar name inference by setting the autoEnvvarPrefix on a command\u2019s context . This will cause all options without an explicit envvar name to be given an uppercase underscore-separated envvar name. Since the prefix is set on the context , it is propagated to subcommands. If you have a a subcommand called foo with an option --bar , and your prefix is MY_TOOL , the option\u2019s envvar name will be MY_TOOL_FOO_BAR . Example class Hello : CliktCommand () { init { context { autoEnvvarPrefix = \"HELLO\" } } val name by option () override fun run () { echo ( \"Hello $ name \" ) } } Usage $ export HELLO_NAME=Foo $ ./hello Hello Foo Multiple Values from Environment Variables \u00b6 You might need to allow users to specify multiple values for an option in a single environment variable. You can do this by creating an option with split . Flag Option Values from Environment Variables \u00b6 For flag options, any of the following (case-insensitive) environment variable values will be interpreted as true : \"true\" , \"t\" , \"1\" , \"yes\" , \"y\" , \"on\" The following (case-insensitive) values wil be interpreted as false : \"false\" , \"f\" , \"0\" , \"no\" , \"n\" , \"off\" All other values are invalid. Overriding system environment variables \u00b6 You can set a custom function that will be used instead of the system environment variables with ContextBuilder.envvarReader . @Test fun `test envvar` () { val envvars = mapOf ( \"MY_TOOL_OPTION\" to \"value\" ) val tool = MyTool (). context { envvarReader = { envvars [ it ] } } tool . parse ( emptyList ()) assertEquals ( \"value\" , tool . option ) } Values from Configuration Files \u00b6 Clikt also supports reading option values from one or more configuration files (or other sources) when they aren\u2019t present on the command line. For example, when using git commit , you can set the author email with a command line parameter: git commit --author='Clikt <clikt@example.com> . But you can also set it in your git configuration file: user.email=clikt@example.com . Clikt allows you to specify one or more sources of option values that will be read from with the Context.valueSource builder. Example class Hello : CliktCommand () { init { context { valueSource = PropertiesValueSource . from ( \"myconfig.properties\" ) } } val name by option () override fun run () { echo ( \"Hello $ name \" ) } } Usage $ echo \"name=Foo\" > myconfig.properties $ ./hello Hello Foo You can also pass multiple sources to Context.valueSources , and each source will be searched for the value in order. Clikt includes support for reading values from a map , and (on JVM) from Java Properties files . For these two sources, you can customize the keys used to look up options by passing the result of ValueSource.getKey or ValueSource.envvarKey to the source\u2019s getKey constructor parameter. You can add any other file type by implementing ValueSource . See the JSON sample for an implementation that uses kotlinx.serialization to load values from JSON files. Configuration Files and Environment Variables \u00b6 Every option can read values from both environment variables and configuration files. By default, Clikt will use the value from an environment variable before the value from a configuration file, but you can change this by setting Context.readEnvvarBeforeValueSource to false . Windows and Java-Style Option Prefixes \u00b6 When specifying option names manually, you can use any prefix (as long as it\u2019s entirely punctuation). For example, you can make a Windows-style interface with slashes: Example class Hello : CliktCommand () { val name by option ( \"/name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Usage $ ./hello /name Foo Hello, Foo! Or you can make a Java-style interface that uses single-dashes for long options: Example class Hello : CliktCommand () { val name by option ( \"-name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Usage $ ./hello -name Foo Hello, Foo! Note that inferred names will always have a POSIX-style prefix like --name . If you want to use a different prefix, you should specify all option names manually. Option Transformation Order \u00b6 Clikt has a large number of extension functions that can modify options. When applying multiple functions to the same option, there\u2019s only one valid order for the functions to be applied. For example, option().default(3).int() will not compile, because default must be applied after the value type conversion. Similarly, you can only apply one transform of each type. So option().int().float() is invalid since int and float both change the value type, as is option().default(\"\").multiple() since default and multiple both transform the call list (if you need a custom default value for multiple , you can pass it one as an argument). Here\u2019s an integer option with one of each available transform in a valid order: val opt : Pair < Int , Int > by option ( \"-o\" , \"--opt\" ) . int () . restrictTo ( 1. . 100 ) . pair () . default ( 1 to 2 ) . validate { require ( it . second % 2 == 0 ) }","title":"Basic Options"},{"location":"options/#options","text":"Options are added to commands by defining a property delegate with the option function.","title":"Options"},{"location":"options/#basic-options","text":"The default option takes one value of type String . The property is nullable. If the option is not given on the command line, the property value will be null. If the option is given at least once, the property will return the value of the last occurrence of the option. Example class Hello : CliktCommand () { val name by option ( help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Usage $ ./hello --name=Foo Hello, Foo!","title":"Basic Options"},{"location":"options/#option-names","text":"If you don\u2019t specify names for an option, a lowercase hyphen-separated name is automatically inferred from the property. For example, val myOpt by option() will create an option that can be called with --my-opt . You can also specify any number of names for an option manually: class Hello : CliktCommand () { val name by option ( \"-n\" , \"--name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Option names that are two characters long (like -n ) are treated as POSIX-style short options. You call them with a value like this: Usage 1 $ ./hello -nfoo Hello, foo! Usage 2 $ ./hello -n foo Hello, foo! All other option names are considered long options, and can be called like this: Usage 1 $ ./hello --name=foo Hello, foo! Usage 2 $ ./hello --name foo Hello, foo!","title":"Option Names"},{"location":"options/#customizing-options","text":"The option behavior and delegate type can be customized by calling extension functions on the option call. For example, here are some different option declarations: val a : String? by option () val b : Int? by option (). int () val c : Pair < Int , Int >? by option (). int (). pair () val d : Pair < Int , Int > by option (). int (). pair (). default ( 0 to 0 ) val e : Pair < Float , Float > by option (). float (). pair (). default ( 0f to 0f ) There are three main types of behavior that can be customized independently: The type of each value in the option. The value type is String by default, but can be customized with built-in functions like int or choice , or manually with convert . This is detailed in the parameters page. The number of values that the option requires. Options take one value by default, but this can be changed with built-in functions like pair and triple , or manually with transformValues . How to handle all calls to the option (i.e. if the option is not present, or is present more than once). By default, the option delegate value is the null if the option is not given on the command line, and will use the value of the last occurrence if the option is given more than once. You can change this behavior with functions like default and multiple . Since the three types of customizations are orthogonal, you can choose which ones you want to use, and if you implement a new customization, it can be used with all of the existing functions without any repeated code.","title":"Customizing Options"},{"location":"options/#default-values","text":"By default, option delegates return null if the option wasn\u2019t provided on the command line. You can instead return a default value with default . Example class Pow : CliktCommand () { val exp by option ( \"-e\" , \"--exp\" ). double (). default ( 1.0 ) override fun run () { echo ( \"2 ^ $ exp = ${ ( 2.0 ). pow ( exp ) } \" ) } } Usage 1 $ ./pow -e 8 2 ^ 8.0 = 256.0 Usage 2 $ ./pow 2 ^ 1.0 = 2.0 If the default value is expensive to compute, or you want to use another parameter as the default, you can use defaultLazy instead of default . It has the same effect, but you give it a lambda returning the default value, and the lambda will only be called if the option isn\u2019t present on the command line.","title":"Default Values"},{"location":"options/#multi-value-options","text":"Options can take any fixed number of values separated by whitespace, or a variable number of values separated by a non-whitespace delimiter you specify. If you want a variable number of values separated by whitespace, you need to use an argument instead.","title":"Multi Value Options"},{"location":"options/#options-with-fixed-number-of-values","text":"There are built in functions for options that take two values ( pair , which uses a Pair ), or three values ( triple , which uses a Triple ). You can change the type of each value as normal with functions like int . If you need more values, you can provide your own container with transformValues . You give that function the number of values you want, and a lambda that will transform a list of values into the output container. The list will always have a size equal to the number you specify. If the user provides a different number of values, Clikt will inform the user and your lambda won\u2019t be called. Example data class Quad < out T > ( val a : T , val b : T , val c : T , val d : T ) fun < T > Quad < T > . toList (): List < T > = listOf ( a , b , c , d ) class Geometry : CliktCommand () { val square by option (). int (). pair () val cube by option (). int (). triple () val tesseract by option (). int (). transformValues ( 4 ) { Quad ( it [ 0 ] , it [ 1 ] , it [ 2 ] , it [ 3 ] ) } override fun run () { echo ( \"Square has dimensions ${ square ?. toList () ?. joinToString ( \" x \" ) } \" ) echo ( \"Cube has dimensions ${ cube ?. toList () ?. joinToString ( \" x \" ) } \" ) echo ( \"Tesseract has dimensions ${ tesseract ?. toList () ?. joinToString ( \" x \" ) } \" ) } } Usage $ ./geometry --square 1 2 --cube 3 4 5 --tesseract 6 7 8 9 Square has dimensions 1x2 Cube has dimensions 3x4x5 Tesseract has dimensions 6x7x8x9","title":"Options With Fixed Number of Values"},{"location":"options/#options-with-a-variable-number-of-values","text":"You can use split to allow a variable number of values to a single option invocation by separating the values with non-whitespace delimiters. This will also split values from environment variables . Example class C : CliktCommand () { val profiles by option ( \"-P\" , envvar = \"PROFILES\" ). split ( \",\" ) override fun run () { for ( profile in profiles ) { echo ( profile ) } } } Usage $ ./split -P profile-1,profile-2 profile-1 profile-2 Usage with Environment Variable $ export PROFILES=profile-1,profile-2 $ ./split profile-1 profile-2","title":"Options With a Variable Number of Values"},{"location":"options/#multiple-options","text":"Normally, when an option is provided on the command line more than once, only the values from the last occurrence are used. But sometimes you want to keep all values provided. For example, git commit -m foo -m bar would create a commit message with two lines: foo and bar . To get this behavior with Clikt, you can use multiple . This will cause the property delegate value to be a list, where each item in the list is the value of from one occurrence of the option. If the option is never given, the list will be empty (or you can specify a default to use). Example class Commit : CliktCommand () { val message : List < String > by option ( \"-m\" ). multiple () override fun run () { echo ( message . joinToString ( \"\\n\" )) } } Usage $ ./commit -m foo -m bar foo bar You can combine multiple with item type conversions and multiple values. val opt : List < Pair < Int , Int >> by option (). int (). pair (). multiple ()","title":"Multiple Options"},{"location":"options/#default-values-for-optionmultiple","text":"You can also supply a default value to multiple or require at least one value be present on the command line. These are specified as arguments rather than with separate extension functions since they don\u2019t change the type of the delegate. Required val opt : List < String > by option (). multiple ( required = true ) Default val opt : List < String > by option (). multiple ( default = listOf ( \"default message\" ))","title":"Default values for option().multiple()"},{"location":"options/#deduplicating-optionmultiple-into-a-unique-set","text":"You can discard duplicate values from a multiple option with unique . Example class Build : CliktCommand () { val platforms : Set < String > by option ( \"-p\" ). multiple (). unique () override fun run () { echo ( \"Building for platforms: $ platforms \" ) } } Usage $ ./build -p android -p ios -p android Building for platforms: [android, ios]","title":"Deduplicating option().multiple() into a unique set"},{"location":"options/#key-value-and-map-options","text":"You can split an option\u2019s value into a key-value pair with splitPair . By default, the delimiter = will be used to split. You can also use associate to allow the option to be specified multiple times, and have its values collected in a map. Example class Build : CliktCommand () { val systemProp : Map < String , String > by option ( \"-D\" , \"--system-prop\" ). associate () override fun run () { echo ( systemProp ) } } Usage $ ./build -Dplace=here --system-prop size=small {place=here, size=small}","title":"Key-Value and Map Options"},{"location":"options/#boolean-flag-options","text":"Flags are options that don\u2019t take a value. Boolean flags can be enabled or disabled, depending on the name used to invoke the option. You can turn an option into a boolean flag with flag . That function takes an optional list of secondary names that will be added to any existing or inferred names for the option. If the option is invoked with one of the secondary names, the delegate will return false. It\u2019s a good idea to always set secondary names so that a user can disable the flag if it was enabled previously. Example class Cli : CliktCommand () { val flag by option ( \"--on\" , \"-o\" ). flag ( \"--off\" , \"-O\" , default = false ) override fun run () { echo ( flag ) } } Usage 1 $ ./cli -o true Usage 2 $ ./cli --on --off false Multiple short flag options can be combined when called on the command line: Example class Cli : CliktCommand () { val flagA by option ( \"-a\" ). flag () val flagB by option ( \"-b\" ). flag () val foo by option ( \"-f\" ) override fun run () { echo ( \" $ flagA $ flagB $ foo \" ) } } Usage $ ./cli -abfFoo true true Foo","title":"Boolean Flag Options"},{"location":"options/#counted-flag-options","text":"You might want a flag option that counts the number of times it occurs on the command line. You can use counted for this. Example class Log : CliktCommand () { val verbosity by option ( \"-v\" ). counted () override fun run () { echo ( \"Verbosity level: $ verbosity \" ) } } Usage $ ./log -vvv Verbosity level: 3","title":"Counted Flag Options"},{"location":"options/#feature-switch-flags","text":"Another way to use flags is to assign a value to each option name. You can do this with switch , which takes a map of option names to values. Note that the names in the map replace any previously specified or inferred names. Example class Size : CliktCommand () { val size by option (). switch ( \"--large\" to \"large\" , \"--small\" to \"small\" ). default ( \"unknown\" ) override fun run () { echo ( \"You picked size $ size \" ) } } Usage $ ./size --small You picked size small","title":"Feature Switch Flags"},{"location":"options/#choice-options","text":"You can restrict the values that a regular option can take to a set of values using choice . You can also map the input values to new types. Example class Digest : CliktCommand () { val hash by option (). choice ( \"md5\" , \"sha1\" ) override fun run () { echo ( hash ) } } Usage 1 $ ./digest --hash=md5 md5 Usage 2 $ ./digest --hash=sha256 Usage: digest [OPTIONS] Error: Invalid value for \"--hash\": invalid choice: sha256. (choose from md5, sha1) Usage 3 $ ./digest --help Usage: digest [OPTIONS] Options: --hash [md5|sha1] -h, --help Show this message and exit","title":"Choice Options"},{"location":"options/#mutually-exclusive-option-groups","text":"If choice or switch options aren\u2019t flexible enough, you can use mutuallyExclusiveOptions to group any nullable options into a mutually exclusive group. If more than one of the options in the group is given on the command line, the last value is used. If you want different types for each option, you can wrap them in a sealed class. Example sealed class Fruit { data class Oranges ( val size : String ): Fruit () data class Apples ( val count : Int ): Fruit () } class Order : CliktCommand () { val fruit : Fruit? by mutuallyExclusiveOptions < Fruit > ( option ( \"--oranges\" ). convert { Oranges ( it ) }, option ( \"--apples\" ). int (). convert { Apples ( it ) } ) override fun run () = echo ( fruit ) } Usage 1 $ ./order --apples=10 Apples(count=10) Usage 2 $ ./order --oranges=small Oranges(size=small) Usage 3 $ ./order --apples=10 --oranges=large Oranges(size=large) You can enforce that only one of the options is given with single : Example val fruit : Fruit? by mutuallyExclusiveOptions < Fruit > ( option ( \"--apples\" ). convert { Apples ( it . toInt ()) }, option ( \"--oranges\" ). convert { Oranges ( it ) } ). single () Usage $ ./order --apples=10 --oranges=small Usage: order [OPTIONS] Error: option --apples cannot be used with --oranges Like regular options, you can make the entire group required , or give it a default value. Like other option groups , you can specify a name and help text for the group if you want to set the group apart in the help output.","title":"Mutually Exclusive Option Groups"},{"location":"options/#co-occurring-option-groups","text":"Sometimes you have a set of options that only make sense when specified together. To enforce this, you can make an option group cooccurring . Co-occurring groups must have at least one required option, and may also have non-required options. The required constraint is enforced if any of the options in the group are given on the command line. If none if the options are given, the value of the group is null. Example class UserOptions : OptionGroup () { val name by option (). required () val age by option (). int () } class Tool : CliktCommand () { val userOptions by UserOptions (). cooccurring () override fun run () { userOptions ?. let { echo ( it . name ) echo ( it . age ) } ?: echo ( \"No user options\" ) } } Usage 1 $ ./tool No user options Usage 2 $ ./tool --name=jane --age=30 jane 30 Usage 3 $ ./tool --age=30 Usage: tool [OPTIONS] Error: Missing option \"--name\". Like other option groups , you can specify a name and help text for the group if you want to set the group apart in the help output.","title":"Co-Occurring Option Groups"},{"location":"options/#choice-and-switch-options-with-groups","text":"If you have different groups of options that only make sense when another option has a certain value, you can use groupChoice and groupSwitch . groupChoice options are similar to choice options , but instead of mapping a value to a single new type, they map a value to a co-occurring OptionGroup . Options for groups other than the selected one are ignored, and only the selected group\u2019s required constraints are enforced. In the same way, groupSwitch options are similar to switch options . Example sealed class LoadConfig ( name : String ): OptionGroup ( name ) class FromDisk : LoadConfig ( \"Options for loading from disk\" ) { val path by option (). file (). required () val followSymlinks by option (). flag () } class FromNetwork : LoadConfig ( \"Options for loading from network\" ) { val url by option (). required () val username by option (). prompt () val password by option (). prompt ( hideInput = true ) } class Tool : CliktCommand ( help = \"An example of a custom help formatter that uses ansi colors\" ) { val load by option (). groupChoice ( \"disk\" to FromDisk (), \"network\" to FromNetwork () ) override fun run () { when ( val it = load ) { is FromDisk -> echo ( \"Loading from disk: ${ it . path } \" ) is FromNetwork -> echo ( \"Loading from network: ${ it . url } \" ) null -> echo ( \"Not loading\" ) } } } Usage 1 $ ./tool --load=disk --path=./config --follow-symlinks Loading from disk: .\\config Usage 2 $ ./tool --load=network --url=www.example.com --username=admin Password: ******* Loading from network: www.example.com Usage 3 $ ./tool --load=disk Usage: cli [OPTIONS] Error: Missing option \"--path\". Usage 4 $ ./tool --load=whoops Usage: cli [OPTIONS] Error: Invalid value for \"--load\": invalid choice: whoops. (choose from disk, network)","title":"Choice and Switch Options With Groups"},{"location":"options/#prompting-for-input","text":"In some cases, you might want to create an option that uses the value given on the command line if there is one, but prompt the user for input if one is not provided. Clikt can take care of this for you with the prompt function. Example class Hello : CliktCommand () { val name by option (). prompt () override fun run () { echo ( \"Hello $ name \" ) } } Usage 1 ./hello --name=foo Hello foo Usage 2 ./hello Name: foo Hello foo The default prompt string is based on the option name, but prompt takes a number of parameters to customize the output.","title":"Prompting For Input"},{"location":"options/#password-prompts","text":"You can also create a option that uses a hidden prompt and asks for confirmation. This combination of behavior is commonly used for passwords. Example class Login : CliktCommand () { val password by option (). prompt ( requireConfirmation = true , hideInput = true ) override fun run () { echo ( \"Your hidden password: $ password \" ) } } Usage $ ./login Password: Repeat for confirmation: Your hidden password: hunter2","title":"Password Prompts"},{"location":"options/#eager-options","text":"Sometimes you want an option to halt execution immediately and print a message. For example, the built-on --help option, or the --version option that many programs have. Neither of these options have any value associated with them, and they stop command line parsing as soon as they\u2019re encountered. The --help option is added automatically to commands, and --version can be added using versionOption . Since the option doesn\u2019t have a value, you can\u2019t define it using a property delegate. Instead, call the function on a command directly, either in an init block, or on a command instance. These definitions are equivalent: Version 1 class Cli : NoOpCliktCommand () { init { versionOption ( \"1.0\" ) } } fun main ( args : Array < String > ) = Cli (). main ( args ) Version 2 class Cli : NoOpCliktCommand () fun main ( args : Array < String > ) = Cli (). versionOption ( \"1.0\" ). main ( args ) Usage $ ./cli --version cli version 1.0 If you want to define your own option with a similar behavior, you can do so by calling eagerOption . This function takes an action that is called when the option is encountered on the command line. To print a message and halt execution normally from the callback, you can throw a PrintMessage exception, and CliktCommand.main will take care of printing the message. If you want to exit normally without printing a message, you can throw Abort(error=false) instead. You can define your own version option like this: class Cli : NoOpCliktCommand () { init { eagerOption ( \"--version\" ) { throw PrintMessage ( \" $ commandName version 1.0\" ) } } }","title":"Eager Options"},{"location":"options/#deprecating-options","text":"You can communicate to users that an option is deprecated with option().deprecated() . By default, this function will add a tag to the option\u2019s help message, and print a warning to stderr if the option is used. You can customize or omit the warning message and help tags, or change the warning into an error. Example class Cli : CliktCommand () { val opt by option ( help = \"option 1\" ). deprecated () val opt2 by option ( help = \"option 2\" ). deprecated ( \"WARNING: --opt2 is deprecated, use --new-opt instead\" , tagName = null ) val opt3 by option ( help = \"option 3\" ). deprecated ( tagName = \"pending deprecation\" , tagValue = \"use --new-opt instead\" ) val opt4 by option ( help = \"option 4\" ). deprecated ( error = true ) override fun run () = echo ( \"command run\" ) } Usage 1 $ ./cli --opt=x WARNING: option --opt is deprecated command run Usage 2 $ ./cli --opt2=x WARNING: --op2 is deprecated, use --new-opt instead command run Usage 3 $ ./cli --opt3=x WARNING: option --opt3 is deprecated command run Usage 4 $ ./cli --opt4=x ERROR: option --opt4 is deprecated Help Output $ ./cli --help Usage: cli [OPTIONS] Options: --opt TEXT option 1 (deprecated) --opt2 TEXT option 2 --opt3 TEXT option 3 (pending deprecation: use --new-opt instead) --opt4 TEXT option 4 (deprecated)","title":"Deprecating Options"},{"location":"options/#unknown-options","text":"You may want to collect unknown options for manual processing. You can do this by passing treatUnknownOptionsAsArgs = true to your CliktCommand constructor . This will cause Clikt to treat unknown options as positional arguments rather than reporting an error when one is encountered. You\u2019ll need to define an argument().multiple() property to collect the options, otherwise an error will still be reported. Example class Wrapper : CliktCommand ( treatUnknownOptionsAsArgs = true ) { init { context { allowInterspersedArgs = false } } val command by option ( help = \"?\" ). required () val arguments by argument (). multiple () override fun run () { val cmd = ( listOf ( command ) + arguments ). joinToString ( \" \" ) val proc = Runtime . getRuntime (). exec ( cmd ) println ( proc . inputStream . bufferedReader (). readText ()) proc . waitFor () } } Usage $ ./wrapper --command=git tag --help | head -n4 GIT-TAG(1) Git Manual GIT-TAG(1) NAME git-tag - Create, list, delete or verify a tag object signed with GPG Note that flag options in a single token (e.g. using -abc to specify -a , -b , and -c in a single token) will still report an error if they are unknown. Each option should be specified separately in this mode. You\u2019ll often want to set allowInterspersedArgs = false on your Context when using treatUnknownOptionsAsArgs . You may also find that subcommands are a better fit than treatUnknownOptionsAsArgs for your use case.","title":"Unknown Options"},{"location":"options/#values-from-environment-variables","text":"Clikt supports reading option values from environment variables if they aren\u2019t given on the command line. This feature is helpful when automating tools. For example, when using git commit , you can set the author date with a command line parameter: git commit --date=10/21/2015 . But you can also set it with an environment variable: GIT_AUTHOR_DATE=10/21/2015 git commit . Clikt will read option values from environment variables as long as it has an envvar name for the option. There are two ways to set that name: you can set the name manually for an option, or you can enable automatic envvar name inference. To set the envvar name manually, pass the name to option : Example class Hello : CliktCommand () { val name by option ( envvar = \"MY_NAME\" ) override fun run () { echo ( \"Hello $ name \" ) } } Usage 1 $ export MY_NAME=Foo $ ./hello Hello Foo Usage 2 $ export MY_NAME=Foo $ ./hello --name=Bar Hello Bar You can enable automatic envvar name inference by setting the autoEnvvarPrefix on a command\u2019s context . This will cause all options without an explicit envvar name to be given an uppercase underscore-separated envvar name. Since the prefix is set on the context , it is propagated to subcommands. If you have a a subcommand called foo with an option --bar , and your prefix is MY_TOOL , the option\u2019s envvar name will be MY_TOOL_FOO_BAR . Example class Hello : CliktCommand () { init { context { autoEnvvarPrefix = \"HELLO\" } } val name by option () override fun run () { echo ( \"Hello $ name \" ) } } Usage $ export HELLO_NAME=Foo $ ./hello Hello Foo","title":"Values From Environment Variables"},{"location":"options/#multiple-values-from-environment-variables","text":"You might need to allow users to specify multiple values for an option in a single environment variable. You can do this by creating an option with split .","title":"Multiple Values from Environment Variables"},{"location":"options/#flag-option-values-from-environment-variables","text":"For flag options, any of the following (case-insensitive) environment variable values will be interpreted as true : \"true\" , \"t\" , \"1\" , \"yes\" , \"y\" , \"on\" The following (case-insensitive) values wil be interpreted as false : \"false\" , \"f\" , \"0\" , \"no\" , \"n\" , \"off\" All other values are invalid.","title":"Flag Option Values from Environment Variables"},{"location":"options/#overriding-system-environment-variables","text":"You can set a custom function that will be used instead of the system environment variables with ContextBuilder.envvarReader . @Test fun `test envvar` () { val envvars = mapOf ( \"MY_TOOL_OPTION\" to \"value\" ) val tool = MyTool (). context { envvarReader = { envvars [ it ] } } tool . parse ( emptyList ()) assertEquals ( \"value\" , tool . option ) }","title":"Overriding system environment variables"},{"location":"options/#values-from-configuration-files","text":"Clikt also supports reading option values from one or more configuration files (or other sources) when they aren\u2019t present on the command line. For example, when using git commit , you can set the author email with a command line parameter: git commit --author='Clikt <clikt@example.com> . But you can also set it in your git configuration file: user.email=clikt@example.com . Clikt allows you to specify one or more sources of option values that will be read from with the Context.valueSource builder. Example class Hello : CliktCommand () { init { context { valueSource = PropertiesValueSource . from ( \"myconfig.properties\" ) } } val name by option () override fun run () { echo ( \"Hello $ name \" ) } } Usage $ echo \"name=Foo\" > myconfig.properties $ ./hello Hello Foo You can also pass multiple sources to Context.valueSources , and each source will be searched for the value in order. Clikt includes support for reading values from a map , and (on JVM) from Java Properties files . For these two sources, you can customize the keys used to look up options by passing the result of ValueSource.getKey or ValueSource.envvarKey to the source\u2019s getKey constructor parameter. You can add any other file type by implementing ValueSource . See the JSON sample for an implementation that uses kotlinx.serialization to load values from JSON files.","title":"Values from Configuration Files"},{"location":"options/#configuration-files-and-environment-variables","text":"Every option can read values from both environment variables and configuration files. By default, Clikt will use the value from an environment variable before the value from a configuration file, but you can change this by setting Context.readEnvvarBeforeValueSource to false .","title":"Configuration Files and Environment Variables"},{"location":"options/#windows-and-java-style-option-prefixes","text":"When specifying option names manually, you can use any prefix (as long as it\u2019s entirely punctuation). For example, you can make a Windows-style interface with slashes: Example class Hello : CliktCommand () { val name by option ( \"/name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Usage $ ./hello /name Foo Hello, Foo! Or you can make a Java-style interface that uses single-dashes for long options: Example class Hello : CliktCommand () { val name by option ( \"-name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $ name !\" ) } } Usage $ ./hello -name Foo Hello, Foo! Note that inferred names will always have a POSIX-style prefix like --name . If you want to use a different prefix, you should specify all option names manually.","title":"Windows and Java-Style Option Prefixes"},{"location":"options/#option-transformation-order","text":"Clikt has a large number of extension functions that can modify options. When applying multiple functions to the same option, there\u2019s only one valid order for the functions to be applied. For example, option().default(3).int() will not compile, because default must be applied after the value type conversion. Similarly, you can only apply one transform of each type. So option().int().float() is invalid since int and float both change the value type, as is option().default(\"\").multiple() since default and multiple both transform the call list (if you need a custom default value for multiple , you can pass it one as an argument). Here\u2019s an integer option with one of each available transform in a valid order: val opt : Pair < Int , Int > by option ( \"-o\" , \"--opt\" ) . int () . restrictTo ( 1. . 100 ) . pair () . default ( 1 to 2 ) . validate { require ( it . second % 2 == 0 ) }","title":"Option Transformation Order"},{"location":"parameters/","text":"Parameters \u00b6 Clikt supports two types of parameters: options and positional arguments. If you\u2019re following Unix conventions with your interface, you should use options for most parameters. Options are usually optional, and arguments are frequently required. Differences \u00b6 Arguments have the advantage of being able to accept a variable number of values, while Options are limited to a fixed number of values. Other than that restriction, options have more capabilities than arguments. Options can: Act as flags (options don\u2019t have to take values) Prompt for missing input Load values from environment variables In general, arguments are usually used for values like file paths or URLs, or for required values, and options are used for everything else. Parameter Names \u00b6 Both options and arguments can infer their names (or the metavar in the case of arguments) from the name of the property. You can also specify the names manually. Options can have any number of names, where arguments only have a single metavar. Example class Cli : CliktCommand () { val inferredOpt by option () val inferred by argument () val explicitOpt by option ( \"-e\" , \"--explicit\" ) val explicitArg by argument ( \"<explicit>\" ) override fun run () = Unit } Help Output Usage: cli [OPTIONS] INFERRED <explicit> Options: --inferred-opt TEXT -e, --explicit TEXT -h, --help Show this message and exit Parameter Types \u00b6 Both options and arguments can convert the String that the user inputs to other types. Types work by transforming the return value of the property delegate. By default parameters have a string type: val opt : String? by option ( help = \"an option\" ) val arg : String by argument ( help = \"an argument\" ) To convert the input to an integer, for example, use the int() extension function: val opt : Int? by option ( help = \"an option\" ). int () val arg : Int by argument ( help = \"an argument\" ). int () Built-In Types \u00b6 There are a number of built in types that can be applied to options and arguments. Int and Long \u00b6 option().int() and argument().int() option().long() and argument().long() By default, any value that fits in the integer type is accepted. You can restrict the values to a range with restrictTo() , which allows you to either clamp the input to the range, or fail with an error if the input is outside the range. Float and Double \u00b6 option().float() and argument().float() option().double() and argument().double() As with integers, you can restrict the input to a range with restrictTo() . Choice \u00b6 option().choice() and argument().choice() You can restrict the values to a set of values, and optionally map the input to a new value. For example, to create an option that only accepts the value \u201cA\u201d or \u201cB\u201d: val opt : String? by option (). choice ( \"a\" , \"b\" ) You can also convert the restricted set of values to a new type: val color : Int? by argument (). choice ( \"red\" to 1 , \"green\" to 2 ) Choice parameters accept values that are case-sensitive by default. This can be configured by passing ignoreCase = true . Enum \u00b6 option().enum() and argument().enum() Like choice , but uses the values of an enum type. enum class Color { RED , GREEN } val color : Color? by option (). enum < Color > () Enum parameters accept case-insensitive values by default. This can be configured by passing ignoreCase = false . File paths \u00b6 option().file() and argument().file() option().path() and argument().path() These conversion functions take extra parameters that allow you to require that values are file paths that have certain attributes, such as that they are directories, or they are writable files. File path InputStream and OutputStream s \u00b6 option().inputStream() and argument().inputStream() option().outputStream() and argument().outputStream() Like file and path , these conversions take file path values, but expose them as open streams for reading or writing. They support the unix convention of passing - to specify stdin or stdout rather than a file on the filesystem. You\u2019ll need to close the streams yourself. You can also use stdin or stdout as their default values. If you need to check if one of these streams is pointing to a file rather than stdin or stdout, you can use isCliktParameterDefaultStdin or isCliktParameterDefaultStdout . Custom Types \u00b6 You can convert parameter values to a custom type by using argument().convert() and option().convert() . These functions take a lambda that converts the input String to any type. If the parameter takes multiple values, or an option appears multiple times in argv , the conversion lambda is called once for each value. Any errors that are thrown from the lambda are automatically caught and a usage message is printed to the user. If you need to trigger conversion failure, you can use fail(\"error message\") instead of raising an exception. For example, you can create an option of type BigDecimal like this: Example class Cli : CliktCommand () { val opt by option (). convert { it . toBigDecimal () } override fun run () = echo ( \"opt= $ opt \" ) } Usage 1 $ ./cli --opt=1.5 opt=1.5 Usage 2 $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": For input string: \"foo\" Metavars \u00b6 You can also pass option().convert() a metavar that will be printed in the help page instead of the default of VALUE . We can modify the above example to use a metavar and an explicit error message: Example class Cli : CliktCommand () { val opt by option ( help = \"a real number\" ). convert ( \"FLOAT\" ) { it . toBigDecimalOrNull () ?: fail ( \"A real number is required\" ) } override fun run () = echo ( \"opt= $ opt \" ) } Usage 1 $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": A real number is required Usage 2 $ ./cli --help Usage: cli [OPTIONS] Options: --opt FLOAT a real number -h, --help Show this message and exit Chaining \u00b6 You can call convert more than once on the same parameter. This allows you to reuse existing conversion functions. For example, you could automatically read the text of a file parameter. Example class FileReader : CliktCommand () { val file : String by argument () . file ( mustExist = true , canBeDir = false ) . convert { it . readText () } override fun run () { echo ( \"Your file contents: $ file \" ) } } Usage $ echo 'some text' > myfile.txt $ ./filereader ./myfile.txt Your file contents: some text Parameter Validation \u00b6 After converting a value to a new type, you can perform additional validation on the converted value with check() and validate() (or the argument equivalents ). check() \u00b6 check() is similar the stdlib function of the same name : it takes lambda that returns a boolean to indicate if the parameter value is valid or not, and reports an error if it returns false. The lambda is only called if the parameter value is non-null. Example class Tool : CliktCommand () { val number by option ( help = \"An even number\" ). int () . check ( \"value must be even\" ) { it % 2 == 0 } override fun run () { echo ( \"number= $ number \" ) } } Usage 1 $ ./tool --number=2 number=2 Usage 2 $ ./tool number=null Usage 3 $ ./tool --number=1 Usage: tool [OPTIONS] Error: invalid value for --number: value must be even validate() \u00b6 For more complex validation, you can use validate() . This function takes a lambda that returns nothing, but can call fail(\"error message\") if the value is invalid. You can also call require() , which will fail if the provided expression is false. Like check , the lambda is only called if the value is non-null. The lambdas you pass to validate are called after the values for all options and arguments have been set, so (unlike in transforms) you can reference other parameters: Example class Tool : CliktCommand () { val number by option (). int (). default ( 0 ) val biggerNumber by option (). int (). validate { require ( it > number ) { \"--bigger-number must be bigger than --number\" } } override fun run () { echo ( \"number= $ number , biggerNumber= $ biggerNumber \" ) } } Usage 1 $ ./tool --number=1 number=1, biggerNumber=null Usage 2 $ ./tool --number=1 --bigger-number=0 Usage: tool [OPTIONS] Error: --bigger-number must be bigger than --number","title":"Differences"},{"location":"parameters/#parameters","text":"Clikt supports two types of parameters: options and positional arguments. If you\u2019re following Unix conventions with your interface, you should use options for most parameters. Options are usually optional, and arguments are frequently required.","title":"Parameters"},{"location":"parameters/#differences","text":"Arguments have the advantage of being able to accept a variable number of values, while Options are limited to a fixed number of values. Other than that restriction, options have more capabilities than arguments. Options can: Act as flags (options don\u2019t have to take values) Prompt for missing input Load values from environment variables In general, arguments are usually used for values like file paths or URLs, or for required values, and options are used for everything else.","title":"Differences"},{"location":"parameters/#parameter-names","text":"Both options and arguments can infer their names (or the metavar in the case of arguments) from the name of the property. You can also specify the names manually. Options can have any number of names, where arguments only have a single metavar. Example class Cli : CliktCommand () { val inferredOpt by option () val inferred by argument () val explicitOpt by option ( \"-e\" , \"--explicit\" ) val explicitArg by argument ( \"<explicit>\" ) override fun run () = Unit } Help Output Usage: cli [OPTIONS] INFERRED <explicit> Options: --inferred-opt TEXT -e, --explicit TEXT -h, --help Show this message and exit","title":"Parameter Names"},{"location":"parameters/#parameter-types","text":"Both options and arguments can convert the String that the user inputs to other types. Types work by transforming the return value of the property delegate. By default parameters have a string type: val opt : String? by option ( help = \"an option\" ) val arg : String by argument ( help = \"an argument\" ) To convert the input to an integer, for example, use the int() extension function: val opt : Int? by option ( help = \"an option\" ). int () val arg : Int by argument ( help = \"an argument\" ). int ()","title":"Parameter Types"},{"location":"parameters/#built-in-types","text":"There are a number of built in types that can be applied to options and arguments.","title":"Built-In Types"},{"location":"parameters/#int-and-long","text":"option().int() and argument().int() option().long() and argument().long() By default, any value that fits in the integer type is accepted. You can restrict the values to a range with restrictTo() , which allows you to either clamp the input to the range, or fail with an error if the input is outside the range.","title":"Int and Long"},{"location":"parameters/#float-and-double","text":"option().float() and argument().float() option().double() and argument().double() As with integers, you can restrict the input to a range with restrictTo() .","title":"Float and Double"},{"location":"parameters/#choice","text":"option().choice() and argument().choice() You can restrict the values to a set of values, and optionally map the input to a new value. For example, to create an option that only accepts the value \u201cA\u201d or \u201cB\u201d: val opt : String? by option (). choice ( \"a\" , \"b\" ) You can also convert the restricted set of values to a new type: val color : Int? by argument (). choice ( \"red\" to 1 , \"green\" to 2 ) Choice parameters accept values that are case-sensitive by default. This can be configured by passing ignoreCase = true .","title":"Choice"},{"location":"parameters/#enum","text":"option().enum() and argument().enum() Like choice , but uses the values of an enum type. enum class Color { RED , GREEN } val color : Color? by option (). enum < Color > () Enum parameters accept case-insensitive values by default. This can be configured by passing ignoreCase = false .","title":"Enum"},{"location":"parameters/#file-paths","text":"option().file() and argument().file() option().path() and argument().path() These conversion functions take extra parameters that allow you to require that values are file paths that have certain attributes, such as that they are directories, or they are writable files.","title":"File paths"},{"location":"parameters/#file-path-inputstream-and-outputstreams","text":"option().inputStream() and argument().inputStream() option().outputStream() and argument().outputStream() Like file and path , these conversions take file path values, but expose them as open streams for reading or writing. They support the unix convention of passing - to specify stdin or stdout rather than a file on the filesystem. You\u2019ll need to close the streams yourself. You can also use stdin or stdout as their default values. If you need to check if one of these streams is pointing to a file rather than stdin or stdout, you can use isCliktParameterDefaultStdin or isCliktParameterDefaultStdout .","title":"File path InputStream and OutputStreams"},{"location":"parameters/#custom-types","text":"You can convert parameter values to a custom type by using argument().convert() and option().convert() . These functions take a lambda that converts the input String to any type. If the parameter takes multiple values, or an option appears multiple times in argv , the conversion lambda is called once for each value. Any errors that are thrown from the lambda are automatically caught and a usage message is printed to the user. If you need to trigger conversion failure, you can use fail(\"error message\") instead of raising an exception. For example, you can create an option of type BigDecimal like this: Example class Cli : CliktCommand () { val opt by option (). convert { it . toBigDecimal () } override fun run () = echo ( \"opt= $ opt \" ) } Usage 1 $ ./cli --opt=1.5 opt=1.5 Usage 2 $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": For input string: \"foo\"","title":"Custom Types"},{"location":"parameters/#metavars","text":"You can also pass option().convert() a metavar that will be printed in the help page instead of the default of VALUE . We can modify the above example to use a metavar and an explicit error message: Example class Cli : CliktCommand () { val opt by option ( help = \"a real number\" ). convert ( \"FLOAT\" ) { it . toBigDecimalOrNull () ?: fail ( \"A real number is required\" ) } override fun run () = echo ( \"opt= $ opt \" ) } Usage 1 $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": A real number is required Usage 2 $ ./cli --help Usage: cli [OPTIONS] Options: --opt FLOAT a real number -h, --help Show this message and exit","title":"Metavars"},{"location":"parameters/#chaining","text":"You can call convert more than once on the same parameter. This allows you to reuse existing conversion functions. For example, you could automatically read the text of a file parameter. Example class FileReader : CliktCommand () { val file : String by argument () . file ( mustExist = true , canBeDir = false ) . convert { it . readText () } override fun run () { echo ( \"Your file contents: $ file \" ) } } Usage $ echo 'some text' > myfile.txt $ ./filereader ./myfile.txt Your file contents: some text","title":"Chaining"},{"location":"parameters/#parameter-validation","text":"After converting a value to a new type, you can perform additional validation on the converted value with check() and validate() (or the argument equivalents ).","title":"Parameter Validation"},{"location":"parameters/#check","text":"check() is similar the stdlib function of the same name : it takes lambda that returns a boolean to indicate if the parameter value is valid or not, and reports an error if it returns false. The lambda is only called if the parameter value is non-null. Example class Tool : CliktCommand () { val number by option ( help = \"An even number\" ). int () . check ( \"value must be even\" ) { it % 2 == 0 } override fun run () { echo ( \"number= $ number \" ) } } Usage 1 $ ./tool --number=2 number=2 Usage 2 $ ./tool number=null Usage 3 $ ./tool --number=1 Usage: tool [OPTIONS] Error: invalid value for --number: value must be even","title":"check()"},{"location":"parameters/#validate","text":"For more complex validation, you can use validate() . This function takes a lambda that returns nothing, but can call fail(\"error message\") if the value is invalid. You can also call require() , which will fail if the provided expression is false. Like check , the lambda is only called if the value is non-null. The lambdas you pass to validate are called after the values for all options and arguments have been set, so (unlike in transforms) you can reference other parameters: Example class Tool : CliktCommand () { val number by option (). int (). default ( 0 ) val biggerNumber by option (). int (). validate { require ( it > number ) { \"--bigger-number must be bigger than --number\" } } override fun run () { echo ( \"number= $ number , biggerNumber= $ biggerNumber \" ) } } Usage 1 $ ./tool --number=1 number=1, biggerNumber=null Usage 2 $ ./tool --number=1 --bigger-number=0 Usage: tool [OPTIONS] Error: --bigger-number must be bigger than --number","title":"validate()"},{"location":"quickstart/","text":"Quick Start \u00b6 You can get the library using any maven-compatible build system. Installation instructions can be found in the README . Basic Concepts \u00b6 Clikt command line interfaces are created by using property delegates inside of a CliktCommand . The normal way to use Clikt is to forward argv from your main function to CliktCommand.main . The simplest command with no parameters would look like this: class Hello : CliktCommand () { override fun run () { echo ( \"Hello World!\" ) } } fun main ( args : Array < String > ) = Hello (). main ( args ) And what it looks like to use: $ ./hello Hello World! A help page is generated automatically: $ ./hello --help Usage: hello [OPTIONS] Options: -h, --help Show this message and exit Printing to Stdout and Stderr \u00b6 Why does this example use echo instead of println ? Although println works, it can cause problems with multi-platform support. echo automatically translates line breaks into the line separator for the current platform. So you don\u2019t have to worry that some of your users will see mangled output because you didn\u2019t test on Windows. You can also pass err=true to echo to print to stderr instead of stdout. Nesting Commands \u00b6 Instances of any command can be attached to other commands, allowing arbitrary nesting of commands. For example, you could write a script to manage a database: Example class Database : CliktCommand () { override fun run () = Unit } class Init : CliktCommand ( help = \"Initialize the database\" ) { override fun run () { echo ( \"Initialized the database.\" ) } } class Drop : CliktCommand ( help = \"Drop the database\" ) { override fun run () { echo ( \"Dropped the database.\" ) } } fun main ( args : Array < String > ) = Database () . subcommands ( Init (), Drop ()) . main ( args ) Usage $ ./db init Initialized the database. Help Output $ ./db --help Usage: database [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: init Initialize the database drop Drop the database Adding Parameters \u00b6 To add parameters, use the option and argument property delegates: Example class Hello : CliktCommand () { val count by option ( help = \"Number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () { for ( i in 1. . count ) { echo ( \"Hello $ name !\" ) } } } Help Output $ ./hello --help Usage: hello [OPTIONS] NAME Options: --count INT Number of greetings -h, --help Show this message and exit Developing Command Line Applications With Gradle \u00b6 When you write a command line application, you probably want to be able to run it without invoking java -jar ... every time. If you\u2019re using Gradle, the application plugin provides a gradle task that bundles your program jars and scripts to launch them. It makes it easy to build a zip or tarball that you can distribute to your users without them needing to perform any incantations like setting up a classpath. You can see this plugin in use the in Clikt samples . The application plugin also creates tasks that will build then run your main function directly from within gradle. Although it seems like these tasks would make development easier, they are not recommended for use with command line programs. Unfortunately, due to the way gradle is designed, command line arguments are not visible to the task. Although you can hack the task to split up a gradle property and pass it in to your argv, this approach is limited. Additionally, stdin, stdout, and environment variables are all captured by gradle. All these limitations make the run task mostly useless for command line applications. An easier way to do development is to used the installDist task provided by the plugin. This builds all the distribution scripts in your build folder, which you can then execute normally. See Clikt\u2019s runsample script for an example of this approach.","title":"Basic Concepts"},{"location":"quickstart/#quick-start","text":"You can get the library using any maven-compatible build system. Installation instructions can be found in the README .","title":"Quick Start"},{"location":"quickstart/#basic-concepts","text":"Clikt command line interfaces are created by using property delegates inside of a CliktCommand . The normal way to use Clikt is to forward argv from your main function to CliktCommand.main . The simplest command with no parameters would look like this: class Hello : CliktCommand () { override fun run () { echo ( \"Hello World!\" ) } } fun main ( args : Array < String > ) = Hello (). main ( args ) And what it looks like to use: $ ./hello Hello World! A help page is generated automatically: $ ./hello --help Usage: hello [OPTIONS] Options: -h, --help Show this message and exit","title":"Basic Concepts"},{"location":"quickstart/#printing-to-stdout-and-stderr","text":"Why does this example use echo instead of println ? Although println works, it can cause problems with multi-platform support. echo automatically translates line breaks into the line separator for the current platform. So you don\u2019t have to worry that some of your users will see mangled output because you didn\u2019t test on Windows. You can also pass err=true to echo to print to stderr instead of stdout.","title":"Printing to Stdout and Stderr"},{"location":"quickstart/#nesting-commands","text":"Instances of any command can be attached to other commands, allowing arbitrary nesting of commands. For example, you could write a script to manage a database: Example class Database : CliktCommand () { override fun run () = Unit } class Init : CliktCommand ( help = \"Initialize the database\" ) { override fun run () { echo ( \"Initialized the database.\" ) } } class Drop : CliktCommand ( help = \"Drop the database\" ) { override fun run () { echo ( \"Dropped the database.\" ) } } fun main ( args : Array < String > ) = Database () . subcommands ( Init (), Drop ()) . main ( args ) Usage $ ./db init Initialized the database. Help Output $ ./db --help Usage: database [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: init Initialize the database drop Drop the database","title":"Nesting Commands"},{"location":"quickstart/#adding-parameters","text":"To add parameters, use the option and argument property delegates: Example class Hello : CliktCommand () { val count by option ( help = \"Number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () { for ( i in 1. . count ) { echo ( \"Hello $ name !\" ) } } } Help Output $ ./hello --help Usage: hello [OPTIONS] NAME Options: --count INT Number of greetings -h, --help Show this message and exit","title":"Adding Parameters"},{"location":"quickstart/#developing-command-line-applications-with-gradle","text":"When you write a command line application, you probably want to be able to run it without invoking java -jar ... every time. If you\u2019re using Gradle, the application plugin provides a gradle task that bundles your program jars and scripts to launch them. It makes it easy to build a zip or tarball that you can distribute to your users without them needing to perform any incantations like setting up a classpath. You can see this plugin in use the in Clikt samples . The application plugin also creates tasks that will build then run your main function directly from within gradle. Although it seems like these tasks would make development easier, they are not recommended for use with command line programs. Unfortunately, due to the way gradle is designed, command line arguments are not visible to the task. Although you can hack the task to split up a gradle property and pass it in to your argv, this approach is limited. Additionally, stdin, stdout, and environment variables are all captured by gradle. All these limitations make the run task mostly useless for command line applications. An easier way to do development is to used the installDist task provided by the plugin. This builds all the distribution scripts in your build folder, which you can then execute normally. See Clikt\u2019s runsample script for an example of this approach.","title":"Developing Command Line Applications With Gradle"},{"location":"utilities/","text":"Utilities \u00b6 Writing command line interfaces often involves more than just parsing the command line. Clikt also provides functions to perform actions commonly used in command line programs. Launching Editors \u00b6 If you need to ask users for multi-line input, or need to have the user edit a file, you can do so through editText and editFile . These functions open the program defined in the VISUAL or EDITOR environment variables, or a sensible default if neither are defined. The functions return the edited text if the user saved their changes. Example fun getCommitMessage (): String? { val message = \"\"\" # Enter your message. # Lines starting with # are ignored \"\"\" . trimIndent () return editText ( message , requireSave = true ) ?. replace ( Regex ( \"#[^\\n]*\\n\" ), \"\" ) } Input Prompts \u00b6 Options can prompt for values automatically , but you can also do so manually with prompt . By default, it accepts any input string, but you can also pass in a conversion function. If the conversion raises a UsageError , the prompt will ask the user to enter a different value. Example val input = prompt ( \"Enter a number\" ) { it . toIntOrNull () ?: throw UsageError ( \" $ it is not a valid integer\" ) } echo ( \"Twice your number is ${ input * 2 } \" ) Interactive Session Enter a number: foo Error: foo is not a valid integer Enter a number: 11 Twice your number is 22 Confirmation Prompts \u00b6 You can also ask the user for a yes or no response with confirm : if ( confirm ( \"Continue?\" ) == true ) { echo ( \"OK!\" ) } If you simply want to abort the program in the user gives a negative response, you can pass abort=true : confirm ( \"Continue?\" , abort = true )","title":"Launching Editors"},{"location":"utilities/#utilities","text":"Writing command line interfaces often involves more than just parsing the command line. Clikt also provides functions to perform actions commonly used in command line programs.","title":"Utilities"},{"location":"utilities/#launching-editors","text":"If you need to ask users for multi-line input, or need to have the user edit a file, you can do so through editText and editFile . These functions open the program defined in the VISUAL or EDITOR environment variables, or a sensible default if neither are defined. The functions return the edited text if the user saved their changes. Example fun getCommitMessage (): String? { val message = \"\"\" # Enter your message. # Lines starting with # are ignored \"\"\" . trimIndent () return editText ( message , requireSave = true ) ?. replace ( Regex ( \"#[^\\n]*\\n\" ), \"\" ) }","title":"Launching Editors"},{"location":"utilities/#input-prompts","text":"Options can prompt for values automatically , but you can also do so manually with prompt . By default, it accepts any input string, but you can also pass in a conversion function. If the conversion raises a UsageError , the prompt will ask the user to enter a different value. Example val input = prompt ( \"Enter a number\" ) { it . toIntOrNull () ?: throw UsageError ( \" $ it is not a valid integer\" ) } echo ( \"Twice your number is ${ input * 2 } \" ) Interactive Session Enter a number: foo Error: foo is not a valid integer Enter a number: 11 Twice your number is 22","title":"Input Prompts"},{"location":"utilities/#confirmation-prompts","text":"You can also ask the user for a yes or no response with confirm : if ( confirm ( \"Continue?\" ) == true ) { echo ( \"OK!\" ) } If you simply want to abort the program in the user gives a negative response, you can pass abort=true : confirm ( \"Continue?\" , abort = true )","title":"Confirmation Prompts"},{"location":"whyclikt/","text":"Why Clikt? \u00b6 There are existing Kotlin libraries for creating command line interfaces, and many Java libraries work in Kotlin as well. However, none of them had all of the following features: Unrestricted composability of commands Fully static type safety for parameters Composable parameter customization that doesn\u2019t require registering converter objects. Full support for Unix command line conventions Capable of reading parameter values from environment variables out of the box Included support for common functionality (keyboard interactivity, line ending normalization, launching editors, etc.) Built-in support for multi-token command aliases Clikt is focused on making writing robust, posix-compliant command line interfaces as easy as possible. A good CLI does more than just parse argv . It allows users to specify values in environment variables, and in some cases prompts for additional input, or opens an editor. Clikt supports all of this out of the box. Some times you need to make a CLI that doesn\u2019t follow Unix conventions. You might be writing for windows, or you want to use the Java style of long options with a single dash. Maybe you need to use a bunch of required options instead of arguments, or you want the help page formatted differently. \u201cBest practices\u201d might not be the best for you, so Clikt tries to make implementing uncommon use-cases as easy as possible. Why not a Kotlin library like kotlin-argparser or kotlinx.cli? \u00b6 Clikt isn\u2019t the only Kotlin CLI library. kotlin-argparser and kotlinx.cli both predate Clikt\u2019s creation. Both, like Clikt, use property delegates to define parameters, but they\u2019re missing most of Clikt features and its extensible design. kotlinx.cli was written by JetBrains and mostly copied kotlin-argparser \u2018s design (and, later, some of Clikt\u2019s). kotlin-argparser works well for simple cases. It\u2019s missing a lot of features that Clikt has, but features could be added. Its real drawback is that it fundamentally does not support composition of commands or parameter values. The lack of subcommand support was already a non-starter, but there are other design decisions that make it unsuitable. In the simple cases, the two libraries are similar. Here\u2019s an example from its README: class MyArgs ( parser : ArgParser ) { val v : Boolean by parser . flagging ( help = \"enable verbose mode\" ) val username : String? by parser . storing ( help = \"name of the user\" ) val count : Int? by parser . storing ( help = \"number of the widgets\" ) { toInt () } val source : List < String > by parser . positionalList ( help = \"source filenames\" ) val destination : String by parser . positional ( help = \"destination\" ) } fun main ( args : Array < String > ) = mainBody { ArgParser ( args ). parseInto ( :: MyArgs ). run { println ( \"Hello, $ username !\" ) println ( \"Moving $ count widgets from $ source to $ destination .\" ) } } Here\u2019s the same thing with Clikt: class Cli : CliktCommand () { val v : Boolean by option ( help = \"enable verbose mode\" ). flag () val username : String? by option ( help = \"name of the user\" ) val count : Int? by option ( help = \"number of the widgets\" ). int () val source : List < String > by argument ( help = \"source filenames\" ). multiple () val destination : String by argument ( help = \"destination\" ) override fun run () { println ( \"Hello, $ name !\" ) println ( \"Moving $ count widgets from $ source to $ destination .\" ) } } fun main ( args : Array < String > ) = Cli (). main ( args ) Both work fine, although you may find Clikt more consistent and a bit less verbose. The differences become more pronounced once you try to do anything that isn\u2019t built in to kotlin-argparser . Maybe you need an option to take two values. Here\u2019s another example from the kotlin-argparser README showing how to do that: fun ArgParser . putting ( vararg names : String , help : String ) = option < MutableMap < String , String >> ( * names , argNames = listOf ( \"KEY\" , \"VALUE\" ), help = help ) { value . orElse { mutableMapOf < String , String > () }. apply { put ( arguments . first (), arguments . last ()) } } fun ArgParser . putting ( help : String ) = ArgParser . DelegateProvider { identifier -> putting ( identifierToOptionName ( identifier ), help = help ) } class MyArgs ( parser : ArgParser ) { val v by parser . putting ( help = \"this takes two values\" ) } Clikt has that functionality built in as option().pair() , but you could implement it yourself like this: class Cli : CliktCommand () { val v by option ( help = \"this takes two values\" ). transformValues ( 2 ) { it [ 0 ] to it [ 1 ] } } The Clikt version is of course much simpler, but there are more fundamental issues with the kotlin-argparser version that drove the creation of Clikt: Its inheritance-based design means that if you wanted to change the type of each value, you would have to copy all of the code for each type. With Clikt, you could just do option().int().transformValues(2) { it[0] to it[1] } Its inheritance-based design means that supporting types, multiple values, and multiple option occurrences would require a combinatorial number of copies of the above code. With Clikt, these are all orthogonal. You have to do all error checking yourself. The argparser example silently discards extra values, or copies the single value, rather than inform the user of the mistake. You could write more code to do so, but Clikt takes care of it for you. Option name inference is not automatic, requiring you to wrap the delegate with yet another function. Each delegate function has a different name, with no indication of whether its creating an option or positional argument. With Clikt, all options are created with option() , and all arguments with argument() . Some of these problems can be solved by writing more code, and some can\u2019t. On the other hand, Clikt attempts to have a consistent, intuitive, composable design that does the right thing without forcing you to think about edge cases. Why not a Java library like JCommander or Picocli? \u00b6 There are a lot of command line libraries for Java. Most are verbose and not composable. Two popular Java libraries that are usable from Kotlin are JCommander and picocli . These libraries use annotations to define parameters, and reflection to set fields. This is functional for simple types, but defining your own types requires you to register a type adapter with the library. This means that type errors are not caught until runtime, and many types of customization are not possible. For example, in JCommander, options that take multiple values cannot be converted to other types. The JCommander docs explain : \u2026 only List is allowed for parameters that define an arity. You will have to convert these values yourself if the parameters you need are of type Integer or other (this limitation is due to Java\u2019s erasure). You also can\u2019t customize many aspects of parsing in JCommander. It can\u2019t infer parameter names. With JCommander, you can\u2019t have an option with multiple values and multiple occurrences at the same time. You can\u2019t have more than one argument, and it can only take one value or an unlimited number of values. You can\u2019t nest subcommands. JCommander and piocli are great libraries if you\u2019re writing code in Java, but we can do much better with Kotlin.","title":"Why not a Kotlin library like kotlin-argparser or kotlinx.cli?"},{"location":"whyclikt/#why-clikt","text":"There are existing Kotlin libraries for creating command line interfaces, and many Java libraries work in Kotlin as well. However, none of them had all of the following features: Unrestricted composability of commands Fully static type safety for parameters Composable parameter customization that doesn\u2019t require registering converter objects. Full support for Unix command line conventions Capable of reading parameter values from environment variables out of the box Included support for common functionality (keyboard interactivity, line ending normalization, launching editors, etc.) Built-in support for multi-token command aliases Clikt is focused on making writing robust, posix-compliant command line interfaces as easy as possible. A good CLI does more than just parse argv . It allows users to specify values in environment variables, and in some cases prompts for additional input, or opens an editor. Clikt supports all of this out of the box. Some times you need to make a CLI that doesn\u2019t follow Unix conventions. You might be writing for windows, or you want to use the Java style of long options with a single dash. Maybe you need to use a bunch of required options instead of arguments, or you want the help page formatted differently. \u201cBest practices\u201d might not be the best for you, so Clikt tries to make implementing uncommon use-cases as easy as possible.","title":"Why Clikt?"},{"location":"whyclikt/#why-not-a-kotlin-library-like-kotlin-argparser-or-kotlinxcli","text":"Clikt isn\u2019t the only Kotlin CLI library. kotlin-argparser and kotlinx.cli both predate Clikt\u2019s creation. Both, like Clikt, use property delegates to define parameters, but they\u2019re missing most of Clikt features and its extensible design. kotlinx.cli was written by JetBrains and mostly copied kotlin-argparser \u2018s design (and, later, some of Clikt\u2019s). kotlin-argparser works well for simple cases. It\u2019s missing a lot of features that Clikt has, but features could be added. Its real drawback is that it fundamentally does not support composition of commands or parameter values. The lack of subcommand support was already a non-starter, but there are other design decisions that make it unsuitable. In the simple cases, the two libraries are similar. Here\u2019s an example from its README: class MyArgs ( parser : ArgParser ) { val v : Boolean by parser . flagging ( help = \"enable verbose mode\" ) val username : String? by parser . storing ( help = \"name of the user\" ) val count : Int? by parser . storing ( help = \"number of the widgets\" ) { toInt () } val source : List < String > by parser . positionalList ( help = \"source filenames\" ) val destination : String by parser . positional ( help = \"destination\" ) } fun main ( args : Array < String > ) = mainBody { ArgParser ( args ). parseInto ( :: MyArgs ). run { println ( \"Hello, $ username !\" ) println ( \"Moving $ count widgets from $ source to $ destination .\" ) } } Here\u2019s the same thing with Clikt: class Cli : CliktCommand () { val v : Boolean by option ( help = \"enable verbose mode\" ). flag () val username : String? by option ( help = \"name of the user\" ) val count : Int? by option ( help = \"number of the widgets\" ). int () val source : List < String > by argument ( help = \"source filenames\" ). multiple () val destination : String by argument ( help = \"destination\" ) override fun run () { println ( \"Hello, $ name !\" ) println ( \"Moving $ count widgets from $ source to $ destination .\" ) } } fun main ( args : Array < String > ) = Cli (). main ( args ) Both work fine, although you may find Clikt more consistent and a bit less verbose. The differences become more pronounced once you try to do anything that isn\u2019t built in to kotlin-argparser . Maybe you need an option to take two values. Here\u2019s another example from the kotlin-argparser README showing how to do that: fun ArgParser . putting ( vararg names : String , help : String ) = option < MutableMap < String , String >> ( * names , argNames = listOf ( \"KEY\" , \"VALUE\" ), help = help ) { value . orElse { mutableMapOf < String , String > () }. apply { put ( arguments . first (), arguments . last ()) } } fun ArgParser . putting ( help : String ) = ArgParser . DelegateProvider { identifier -> putting ( identifierToOptionName ( identifier ), help = help ) } class MyArgs ( parser : ArgParser ) { val v by parser . putting ( help = \"this takes two values\" ) } Clikt has that functionality built in as option().pair() , but you could implement it yourself like this: class Cli : CliktCommand () { val v by option ( help = \"this takes two values\" ). transformValues ( 2 ) { it [ 0 ] to it [ 1 ] } } The Clikt version is of course much simpler, but there are more fundamental issues with the kotlin-argparser version that drove the creation of Clikt: Its inheritance-based design means that if you wanted to change the type of each value, you would have to copy all of the code for each type. With Clikt, you could just do option().int().transformValues(2) { it[0] to it[1] } Its inheritance-based design means that supporting types, multiple values, and multiple option occurrences would require a combinatorial number of copies of the above code. With Clikt, these are all orthogonal. You have to do all error checking yourself. The argparser example silently discards extra values, or copies the single value, rather than inform the user of the mistake. You could write more code to do so, but Clikt takes care of it for you. Option name inference is not automatic, requiring you to wrap the delegate with yet another function. Each delegate function has a different name, with no indication of whether its creating an option or positional argument. With Clikt, all options are created with option() , and all arguments with argument() . Some of these problems can be solved by writing more code, and some can\u2019t. On the other hand, Clikt attempts to have a consistent, intuitive, composable design that does the right thing without forcing you to think about edge cases.","title":"Why not a Kotlin library like kotlin-argparser or kotlinx.cli?"},{"location":"whyclikt/#why-not-a-java-library-like-jcommander-or-picocli","text":"There are a lot of command line libraries for Java. Most are verbose and not composable. Two popular Java libraries that are usable from Kotlin are JCommander and picocli . These libraries use annotations to define parameters, and reflection to set fields. This is functional for simple types, but defining your own types requires you to register a type adapter with the library. This means that type errors are not caught until runtime, and many types of customization are not possible. For example, in JCommander, options that take multiple values cannot be converted to other types. The JCommander docs explain : \u2026 only List is allowed for parameters that define an arity. You will have to convert these values yourself if the parameters you need are of type Integer or other (this limitation is due to Java\u2019s erasure). You also can\u2019t customize many aspects of parsing in JCommander. It can\u2019t infer parameter names. With JCommander, you can\u2019t have an option with multiple values and multiple occurrences at the same time. You can\u2019t have more than one argument, and it can only take one value or an unlimited number of values. You can\u2019t nest subcommands. JCommander and piocli are great libraries if you\u2019re writing code in Java, but we can do much better with Kotlin.","title":"Why not a Java library like JCommander or Picocli?"}]}